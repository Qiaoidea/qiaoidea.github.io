
  
    <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Qiaoidea&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Qiaoidea">
    
    <meta name="description" content="Android">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Qiaoidea&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

      <body>
        <header>
          <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiaoidea&#39;s Blog" title="Qiaoidea&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiaoidea&#39;s Blog">Qiaoidea&#39;s Blog</a></h1>
				<h2 class="blog-motto">你必须非常努力，才能看起来毫不费力。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/dj">札记</a></li>
					
						<li><a href="/programing_art">编程艺术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qiaoidea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
        </header>
        <div id="container">
          <div id="main" class="page" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/programing_art/ebook/en/11.0.html" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="http://qiaoidea.github.io/about" title="Qiaoidea" target="_blank" itemprop="author">Qiaoidea</a>
		
  <p class="article-time">
    <time datetime="2015-01-10T11:57:42.000Z" itemprop="datePublished"> 发表于 1月 10 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="Chapter_11:_Longest_Common_Subsequence_">Chapter 11: Longest Common Subsequence </h1>
<h2 id="1-_Introduction">1. Introduction</h2>
<p>What is this so-called longest common subsequence (LCS)? Given a sequence S, if it is a subsequence of two or more sequences, and it is also the longest one among these sequences, then S is the LCS of these sequences.</p>
<p>For example, given two random sequences: 1 3 4 5 5, and 2 4 5 5 7 6, their LCS is: 4 5 5.</p>
<p>There is another confusing concept called ‘longest common substring’, please pay attention to the difference between ‘longest common substring’ and ‘longest common subsequence’: a substring is a continual part of the original sequence, which means every element in the substring has to be adjacent in the original one; but a subsequence just needs to keep the order, the elements do not need to be adjacent. For example, for strings ‘acdfg’ and ‘akdfc’, their longest common substring is ‘df’, and longest common subsequence is ‘adf’. The LCS problem can be solved using Dynamic Programming as described below.</p>
<h2 id="2-_Solution_Ideas">2. Solution Ideas</h2>
<ul>
<li><p>Brute Force<br>Brute force is the easiest algorithm that comes to our mind. For every subsequence of sequence X, check if it is the subsequence of sequence Y, therefore identify whether it is a common subsequence of X and Y, and record the longest one during this procedure. After all the subsequences of X is examined, we get the LCS of X and Y. For a sequence X with m elements, denoted by index as {1,2,…,m}, its subsequence can be denoted as a subsequence of {1,2,…,m}. We can infer from this that X has 2^m subsequences, so the complexity of brute force is exponential (2^n).</p>
</li>
<li><p>Dynamic Programming<br>We notice that the LCS problem has the <em>optimal substructure</em> attribute.<br>For X with m elements and Y with n elements, denote:<br>  <code>Xi = &lt;x1,x2,...,xi&gt;</code>, first i elements of sequence X (1 ≤ i ≤ m)<br>  <code>Yj = &lt;y1,y2,...,yj&gt;</code>, first j elements of sequence Y (1 ≤ j ≤ n)<br>Assume <code>Z = &lt;z1,z2,...,zk&gt; ∈ LCS(X, Y)</code>.<br>  If xm = yn (the last element of X and Y is the same), then it is not difficult to prove that this element must also be the last element of Z, i.e. zk = xm = yn. And obviously, Zk-1 ∈ LCS(Xm-1, Yn-1), so the original problem is reduced to find LCS(Xm-1,Yn-1), then plus xm; and the length of LCS(X, Y) is length(LCS(Xm-1, Yn-1)) + 1;<br>  If xm ≠ yn, we can also prove either Z ∈ LCS(Xm-1, Y), or Z ∈ LCS(X, Yn-1). Now the problem reduce to find the LCS(Xm-1, Y) and LCS(X, Yn-1), and pick the longer one. The length of LCS(X,Y) is max{length(LCS(Xm-1,Y)), length(LCS(X,Yn-1))}.</p>
</li>
</ul>
<p>In the situation when xm ≠ yn, we need to compute the length of LCS(Xm-1, Y) and LCS(X, Yn-1), which both depend on the length of LCS(Xm-1, Yn-1). Furthermore, LCS(X, Y) must contain LCS(Xi, Yj), so this problem has the optimal substructure attribute and therefore we can try Dynamic Programming.</p>
<p>In all, you need 3 things to solve this LCS problem:  </p>
<ol>
<li><code>LCS(Xm-1, Yn-1)+1;</code></li>
<li><code>LCS(Xm-1, Y), LCS(X, Yn-1);</code></li>
<li><code>max{length(LCS(Xm-1, Y), length(LCS(X, Yn-1)}.</code></li>
</ol>
<p>I will try to detail the algorithm next.</p>
<h2 id="3-_Dynamic_Programming_Solution_For_LCS">3. Dynamic Programming Solution For LCS</h2>
<h3 id="3-1_Stucture_of_LCS_problem">3.1 Stucture of LCS problem</h3>
<p>The structure of LCS can be represented as below:  </p>
<pre><code>Denote a LCS of sequence X=&lt;x1,x2,<span class="keyword">...</span>,xm&gt; and Y=&lt;y1,y2,<span class="keyword">...</span>,yn&gt; as Z=&lt;z1,z2,<span class="keyword">...</span>,zk&gt;, we have:  
    a. <span class="keyword">if</span> xm=yn, then zk=xm=yn and Zk-<span class="number">1</span> is the LCS of Xm-<span class="number">1</span> and Yn-<span class="number">1</span>;
    b. <span class="keyword">if</span> xm≠yn and zk≠xm, then Z is the LCS of Xm-<span class="number">1</span> and Yn;
    c. <span class="keyword">if</span> xm≠yn and zk≠yn, then Z is the LCS of X and Yn-<span class="number">1</span>;
Note: Xm-<span class="number">1</span>=&lt;x1,x2,<span class="keyword">...</span>,xm-<span class="number">1</span>&gt;, Yn-<span class="number">1</span>=&lt;y1,y2,<span class="keyword">...</span>,yn-<span class="number">1</span>&gt;, Zk-<span class="number">1</span>=&lt;z1,z2,<span class="keyword">...</span>,zk-<span class="number">1</span>&gt;.
</code></pre><h3 id="3-2_Recursive_Structure_of_the_Subproblem">3.2 Recursive Structure of the Subproblem</h3>
<p>From the optimal substructure stated in the previous subsection, we know that, to find the LCS of X and Y, we just need to go through the following procedure:<br>if xm=yn, find the LCS of Xm-1 and Yn-1 and then append xm (or yn);<br>if xm≠yn, find the LCS of Xm-1 and Y, and the LCS of X and Yn-1, then pick the longer one.</p>
<p>We can see a <em>overlapping subproblems</em> attribute from this recursive structure. For example, when finding the LCS of X and Y, we may need to find the LCS of X and Yn-1 and the LCS of Xn-1 and Y first; and these two both depend on one subproblem, to find the LCS of Xm-1 and Yn-1.</p>
<p>So let us build the recursive relations among the optimal values of the subproblems.<br>Denote c[i,j] as the length of Xi and Yj. When i=0 or j=0, the LCS of Xi and Yj is an empty sequence, so c[i,j]=0, otherwise the recursive relation can be defined as:<br><img src="../images/11/11.1.jpg" alt=""></p>
<h3 id="3-3_Computing_the_Optimal_Value_(length_of_the_LCS)">3.3 Computing the Optimal Value (length of the LCS)</h3>
<p>Using the recursive formula defined above, we can easily contrive an algorithm to compute c[i,j], but the execution time will grow exponentially with the length of input. Since there are only θ(m*n) subproblems in the subporblem space, we can use the bottom-up approach to improve efficiency.</p>
<p>The LCS_LENGTH(X,Y) algorithm takes X=&lt; x1,x2,…,xm &gt; and Y=&lt; y1,y2,…,yn &gt; as inputs and then outputs two matrices c[0..m, 0..n] and b[1..m, 1..n]; c[i,j] stores the length of LCS(Xi, Yj), and b[i,j] stores where c[i,j] gets its value from (this will be explained later). At the end of the algorithm, the length of LCS(X,Y) will be stored at c[m,n].</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Procedure LCS_LENGTH(X,Y);  </div><div class="line">begin  </div><div class="line">  m:=<span class="built_in">length</span>[X];  </div><div class="line">  n:=<span class="built_in">length</span>[Y];  </div><div class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="built_in">to</span> m <span class="built_in">do</span> c[i,<span class="number">0</span>]:=<span class="number">0</span>;  </div><div class="line">  <span class="keyword">for</span> j:=<span class="number">1</span> <span class="built_in">to</span> n <span class="built_in">do</span> c[<span class="number">0</span>,j]:=<span class="number">0</span>;  </div><div class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="built_in">to</span> m <span class="built_in">do</span>  </div><div class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="built_in">to</span> n <span class="built_in">do</span>  </div><div class="line">      <span class="keyword">if</span> x[i]=y[j] <span class="keyword">then</span>  </div><div class="line">        begin  </div><div class="line">          c[i,j]:=c[i-<span class="number">1</span>,j-<span class="number">1</span>]+<span class="number">1</span>;  </div><div class="line">          b[i,j]:=<span class="string">"↖"</span>;  </div><div class="line">        <span class="function"><span class="keyword">end</span>  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> c[i-<span class="number">1</span>,j]≥c[i,j-<span class="number">1</span>] <span class="keyword">then</span>  </div><div class="line">        begin  </div><div class="line">          c[i,j]:=c[i-<span class="number">1</span>,j];  </div><div class="line">          b[i,j]:=<span class="string">"↑"</span>;  </div><div class="line">        <span class="function"><span class="keyword">end</span>  </span></div><div class="line">      <span class="keyword">else</span>  </div><div class="line">        begin  </div><div class="line">          c[i,j]:=c[i,j-<span class="number">1</span>];  </div><div class="line">          b[i,j]:=<span class="string">"←"</span>  </div><div class="line">        <span class="function"><span class="keyword">end</span>;  </span></div><div class="line">  <span class="constant">return</span>(c,b);  </div><div class="line"><span class="function"><span class="keyword">end</span>;</span></div></pre></td></tr></table></figure>

<p>The complexity for computing each entry in the matrix is O(1), and as there are m * n entries altogether, the complexity of LCS_LENGTH is O(mn).</p>
<h3 id="3-4_Construct_the_LCS">3.4 Construct the LCS</h3>
<p>With the help of matirx b from LCS_LENGTH, we can construct the LCS of X and Y. Starting from b[m,n], we can navigate the matrix according to the direction of each ‘arrow’:</p>
<ul>
<li>when b[i,j]=’↖’, it means xi=yi is an element of LCS(Xi,Yj), i.e., LCS(Xi,Yj) is LCS(Xi-1,Yj-1) appends xi (or yj);</li>
<li>when b[i,j]=’↑’, it means LCS(Xi,Yj) is the same as LCS(Xi-1,Yj);</li>
<li>when b[i,j]=’←’, it means LCS(Xi,Yj) is the same as LCS(Xi,Yj-1).</li>
</ul>
<p>This approach traces each element of the LCS of Xi and Yj reversely, The algorithm LCS(b,X,i,j) below will print out the LCS of Xi and Yj. Calling LCS(b,X, length(X), length(Y)) will print out the LCS of X and Y.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Procedure LCS(b,X,i,j);  </div><div class="line"><span class="operator"><span class="keyword">begin</span>  </span></div><div class="line">  <span class="keyword">if</span> i=<span class="number">0</span> <span class="keyword">or</span> j=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span>;  </div><div class="line">  if b[i,j]="↖" then  </div><div class="line">    <span class="operator"><span class="keyword">begin</span>  </span></div><div class="line">      LCS(b,X,i-<span class="number">1</span>,j-<span class="number">1</span>);  </div><div class="line">      print(x[i]);</div><div class="line">    <span class="operator"><span class="keyword">end</span>  </span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> b[i,j]=<span class="string">"↑"</span> <span class="keyword">then</span> LCS(b,X,i-<span class="number">1</span>,j)   </div><div class="line">                      <span class="keyword">else</span> LCS(b,X,i,j-<span class="number">1</span>);  </div><div class="line"><span class="operator"><span class="keyword">end</span>;</span></div></pre></td></tr></table></figure>

<p>In this procedure, each recursion will decrease i or j by 1, and finally stops when i or j becomes 0, so the complexity is O(m+n).</p>
<p>E.g., for two sequences X=&lt; A,B,C,B,D,A,B &gt; and Y=&lt; B,D,C,A,B,A &gt;, the results of LCS_LENGTH() and LCS() can be shown as:<br><img src="../images/11/11.2.jpg" alt=""></p>
<p>Let me explain this diagram. Firstly, LCS_LENGTH() computes matrix c and matrix b from X and Y, and the cell at the ith row and jth column stores the value of c[i,j] and the arrow pointing to next entry of b. At c[7,6], number 4 stands for the length of LCS&lt; B,C,B,A &gt;. To re-construct the LCS, we just need to follow the arrow from the lower right corner (the path is shadowed); each ‘↖’ on the path denotes an element of the LCS (circled).<br>So, according to the diagram, the procedure will finally print out: “B C B A”. </p>
<h3 id="3-5_Improvement">3.5 Improvement</h3>
<p>To any specific problem, we can design an effective algorithm based on some common design strategies, but usually we can still get some time and space improvements by considering the nature of the problem.</p>
<p>In this problem, the space for matrix b will not be necessary. In fact, we already konw that c[i,j] depends on one of c[i-1,j-1], c[i-1,j], and c[i,j-1]; and b[i,j] is only needed to indicate which one is what we need. So we can use matrix c itself to decide this (with some comparisons) instead of looking at matrix b, and therefore we save O(mn) space. But the space needed by matrix c is still O(mn), the improvment will a constant factor. </p>
<p>Moreover, if we only need the length of LCS, the space requirement can be reduced greatly. In fact, when computing c[i,j], only the ith row and i-1th row is needed, so we just need 2 rows of space to compute the length of the LCS. With further analysis, the space requirement can be reduced further to min(m,n).</p>
<h2 id="4-_Solution_Codes">4. Solution Codes</h2>
<p>An implementation of the dynamic programming solution is given below:<br>Let a two-dimensional array f[i][j] denote the length of LCS(Xi, Yj), we have:  </p>
<pre><code>f[<span class="link_label">1</span>][<span class="link_reference">1</span>] = same(1,1)  
f[<span class="link_label">i</span>][<span class="link_reference">j</span>] = max{f[<span class="link_label">i − 1</span>][<span class="link_reference">j − 1</span>] +same(i,j), f[<span class="link_label">i − 1</span>][<span class="link_reference">j</span>] ,f[<span class="link_label">i</span>][<span class="link_reference">j − 1</span>]}  
</code></pre><p>same(i,j) returns true if the ith element of X is the same as the jth elements of Y, otherwise returns false.<br>The time and space complexity for this algorithm are both O(n^2). After optimization, the space complexity can be reduced down to O(n), and the time complexity can be reduced down to O(nlogn).</p>
<p>The java code is shown below:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;  </div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCS</span></span>{  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){  </div><div class="line">   </div><div class="line">        <span class="comment">// set the length of string</span></div><div class="line">        <span class="keyword">int</span> substringLength1 = <span class="number">20</span>;  </div><div class="line">        <span class="keyword">int</span> substringLength2 = <span class="number">20</span>;  <span class="comment">// adjust the number  </span></div><div class="line">   </div><div class="line">        <span class="comment">// generate strings randomly</span></div><div class="line">        String x = GetRandomStrings(substringLength1);  </div><div class="line">        String y = GetRandomStrings(substringLength2);  </div><div class="line">   </div><div class="line">        Long startTime = System.nanoTime();  </div><div class="line">        <span class="comment">// the lengths of LCS(xi, yj) </span></div><div class="line">        <span class="keyword">int</span>[][] opt = <span class="keyword">new</span> <span class="keyword">int</span>[substringLength1 + <span class="number">1</span>][substringLength2 + <span class="number">1</span>];  </div><div class="line">   </div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = substringLength1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--){  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = substringLength2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--){  </div><div class="line">                <span class="keyword">if</span> (x.charAt(i) == y.charAt(j))  </div><div class="line">                    opt[i][j] = opt[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;       <span class="comment">//refer to the fomulars above  </span></div><div class="line">                <span class="keyword">else</span>  </div><div class="line">                    opt[i][j] = Math.max(opt[i + <span class="number">1</span>][j], opt[i][j + <span class="number">1</span>]);     <span class="comment">//refer to the fomulars above      </span></div><div class="line">            }  </div><div class="line">        }  </div><div class="line">   </div><div class="line">        -------------------------------------------------------------------------------------  </div><div class="line">   </div><div class="line">                  /      <span class="number">0</span>                               <span class="keyword">if</span> i&lt;<span class="number">0</span> or j&lt;<span class="number">0</span>  </div><div class="line">        c[i,j]=          c[i-<span class="number">1</span>,j-<span class="number">1</span>]+<span class="number">1</span>                    <span class="keyword">if</span> i,j&gt;=<span class="number">0</span> and xi=xj  </div><div class="line">                 /       max(c[i,j-<span class="number">1</span>],c[i-<span class="number">1</span>,j]           <span class="keyword">if</span> i,j&gt;=<span class="number">0</span> and xi≠xj  </div><div class="line">   </div><div class="line">        -------------------------------------------------------------------------------------  </div><div class="line">   </div><div class="line">        System.out.println(<span class="string">"substring1:"</span> + x);  </div><div class="line">        System.out.println(<span class="string">"substring2:"</span> + y);  </div><div class="line">        System.out.print(<span class="string">"LCS:"</span>);  </div><div class="line">   </div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">while</span> (i &lt; substringLength1 && j &lt; substringLength2){  </div><div class="line">            <span class="keyword">if</span> (x.charAt(i) == y.charAt(j)){  </div><div class="line">                System.out.print(x.charAt(i));  </div><div class="line">                i++;  </div><div class="line">                j++;  </div><div class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (opt[i + <span class="number">1</span>][j] &gt;= opt[i][j + <span class="number">1</span>])  </div><div class="line">                i++;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                j++;  </div><div class="line">        }  </div><div class="line">        Long endTime = System.nanoTime();  </div><div class="line">        System.out.println(<span class="string">" Totle time is "</span> + (endTime - startTime) + <span class="string">" ns"</span>);  </div><div class="line">    }  </div><div class="line">   </div><div class="line">    <span class="comment">// get a length-specified random string  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">GetRandomStrings</span>(<span class="keyword">int</span> length){  </div><div class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>);  </div><div class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </div><div class="line">        Random r = <span class="keyword">new</span> Random();  </div><div class="line">        <span class="keyword">int</span> range = buffer.length();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++){  </div><div class="line">            sb.append(buffer.charAt(r.nextInt(range)));  </div><div class="line">        }  </div><div class="line">        <span class="keyword">return</span> sb.toString();  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="5-_Another_Advanced_Algorithm">5. Another Advanced Algorithm</h2>
<p>Now let us learn another approach that solves the LCS problem. This new approach transforms the original problem into solving a matrix L(p,m), as described below.  </p>
<h3 id="5-1_Definitions_and_Theorems">5.1 Definitions and Theorems</h3>
<ul>
<li>Definition: Given string A=A[1]A[2]…A[m] and string B=B[1]B[2]…B[n], A(1:i) denotes a continual sequence A[1]A[2]…A[i], and so does B(1:j), then Li(k) denotes the minimum value of j for which B(1:j) and A(1:i) have a LCS of length k, i.e., Li(k) = Minj{ length( LCS(A(1:i), B(1:j)) ) = k}</li>
<li>Theorem 1: ∀ i∈[1，m]，Li(l) &lt; Li(2) &lt; Li(3) &lt; … &lt; Li(m)  </li>
<li>Theorem 2: ∀ i∈[1，m-1]，∀k∈[1，m]，Li(k+1) &lt;= Li(k)</li>
<li>Theorem 3: ∀ i∈[1，m-1]，∀k∈[1，m-l]，Li(k) &lt; Li+1(k+l)  </li>
<li>Theorem 4: if Li+1(k) exists, then its value must be: Li+1(k) = Min(j, Li(k)), here j is the minimun integer for which A[i+1]=B[j] and j&gt;Li(k-1).</li>
</ul>
<h3 id="5-2_Algorithm_Ideas">5.2 Algorithm Ideas</h3>
<p><img src="../images/11/11.3.jpg" alt=""></p>
<p>In the matrix shown above, L(k, i) = Li(k), where 1&lt; i &lt;= m and 1 &lt; k &lt;= m, and ‘null’ means L(k, i) doesn not exist. Obviously, there is no L(k,i) when i &lt; k.<br>Let p=Maxk(L(k,m) ≠ null), we can prove that the sequence B[L(1,m-p+1)]B[L(2,m-p+2)]…B[L(p,m)] (the Diagonal of Matrix L(p,m): L(1,m-p+1),L(2,m-p+2)…L(p-1,m-1),L(p,m)) is the LCS of A and B. So the LCS problem changes to compute the matirx L(p,m).<br>According to the theorems, we first compute the 1st row of the matrix, L(1,1), L(1,2),…L(1,m), and then compute the 2nd row, and keep repeating until all entries of the next row (p+1th) is null.<br>During this procedure, the next two rules are used:</p>
<pre><code>（<span class="number">1</span>）<span class="keyword">if</span>(<span class="built_in">i</span>&lt;k), L(k,<span class="built_in">i</span>)=null;
（<span class="number">2</span>）<span class="keyword">if</span> (L(k,<span class="built_in">i</span>)=k), L(k,<span class="built_in">i</span>+<span class="number">1</span>)=L(k,<span class="built_in">i</span>+<span class="number">2</span>)=…L(k,m)=k
</code></pre><p>Since the complexity for solving each row is O(n), the overall complexity is O(pn). During the whole process, only two rows of the matrix (the current one and last one) are needed, so the space complexity is O(m+n).</p>
<p>E.g. Given string A and B, A=acdabbc, B=cddbacaba (m=7, n=9). Following the rules given above, we can get the following L matrix (‘$’ stands for null):<br><img src="../images/11/11.4.jpg" alt="">  </p>
<p>So the LCS of A and B is: B[1]B[2]B[4]B[6]=cdbc, and the length of LCS is 4.</p>
<h3 id="5-3_Pseudocode">5.3 Pseudocode</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">L(A,B,L){ <span class="comment">//string A，B，the wanted matrix L  </span></div><div class="line">  <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=m;k++){    <span class="comment">// m is the length of A</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++){  </div><div class="line">      <span class="keyword">if</span>(i&lt;k) L[k][i]=N;  <span class="comment">// when i&lt;k ,L(k,i)=null</span></div><div class="line">      <span class="keyword">if</span>(L[k][i]==k)      <span class="comment">// when L(k,i)=k,L(k,i+1)=L(k,i+2)=…L(k,m)=k  </span></div><div class="line">      <span class="keyword">for</span>(l=i+<span class="number">1</span>;l&lt;=m;l++)  </div><div class="line">       { L[k][l]=k;  </div><div class="line">         <span class="keyword">Break</span>;}  </div><div class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++){  <span class="comment">// theorem 4</span></div><div class="line">       <span class="keyword">if</span>(A[i+<span class="number">1</span>]==B[j]&&j&gt;L[k-<span class="number">1</span>][i]){  </div><div class="line">        L[k][i+<span class="number">1</span>]=(j&lt;L[k][i]?j:L[k][i]);  </div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">      }  </div><div class="line">      <span class="keyword">if</span>(L[k][i+<span class="number">1</span>]==<span class="number">0</span>)  </div><div class="line">        L[k][i]=N;  </div><div class="line">     }  </div><div class="line">     <span class="keyword">if</span>(L[k][m]==N)  </div><div class="line">      {p=k-<span class="number">1</span>;<span class="keyword">break</span>;}  </div><div class="line">  }  </div><div class="line">  p=k-<span class="number">1</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="5-4_Section_Summary">5.4 Section Summary</h3>
<p>This section discusses a different approach from dynamic programming to solve the LCS problem. To improve the computing speed without affecting accuracy, we make some constrained optimization about the conditions when computing L(p,m). We test this algorithm on Intel (R) Core (TM) 2 Quad dual-core processor, 1Gb RAM, windows XP, and it shows that this algorithm has correct result and improved speed compared to other algorithms.<br><em>This section is inspired by Mrs Liu Jiamei’s thesis.</em></p>
<h2 id="Reference">Reference</h2>
<p>If you find any problem about this article, please let us know. Thank you!<br>END</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>


<div class="article-share" id="share">

  <div data-url="http://qiaoidea.github.io/programing_art/ebook/en/11.0.html" data-title="Qiaoidea&#39;s Blog" data-tsina="5288126184" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
	
<section id="comments" class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
        </div>
        <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 一时不学，差之毫厘； <br/>
			终日不学，失之千里。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5288126184" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2015 
		
		<a href="http://qiaoidea.github.io/about" target="_blank" title="Qiaoidea">Qiaoidea</a>
		
		</p>
</div>
</footer>
        <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"qiaoidea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

      </body>
     </html>
     
