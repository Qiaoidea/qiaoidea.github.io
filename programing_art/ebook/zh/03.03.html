
  
    <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Qiaoidea&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Qiaoidea">
    
    <meta name="description" content="Android">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Qiaoidea&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

      <body>
        <header>
          <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiaoidea&#39;s Blog" title="Qiaoidea&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiaoidea&#39;s Blog">Qiaoidea&#39;s Blog</a></h1>
				<h2 class="blog-motto">你必须非常努力，才能看起来毫不费力。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/dj">札记</a></li>
					
						<li><a href="/programing_art">编程艺术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qiaoidea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
        </header>
        <div id="container">
          <div id="main" class="page" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/programing_art/ebook/zh/03.03.html" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="http://qiaoidea.github.io/about" title="Qiaoidea" target="_blank" itemprop="author">Qiaoidea</a>
		
  <p class="article-time">
    <time datetime="2015-01-10T11:57:47.000Z" itemprop="datePublished"> 发表于 1月 10 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="最近公共祖先LCA问题">最近公共祖先LCA问题</h1>
<h2 id="问题描述">问题描述</h2>
<p>求有根树的任意两个节点的最近公共祖先。</p>
<h2 id="分析与解法">分析与解法</h2>
<p>解答这个问题之前，咱们得先搞清楚到底什么是最近公共祖先。最近公共祖先简称LCA（Lowest Common Ancestor），所谓LCA，是当给定一个有根树T时，对于任意两个结点u、v，找到一个离根最远的结点x，使得x同时是u和v的祖先，x 便是u、v的最近公共祖先。（参见：<a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">http://en.wikipedia.org/wiki/Lowest_common_ancestor</a> ）原问题涵盖一般性的有根树，本文为了简化，多使用二叉树来讨论。</p>
<p>举个例子，如针对下图所示的一棵普通的二叉树来讲：</p>
<p><img src="../images/39/39.1.jpg" alt=""></p>
<p>结点3和结点4的最近公共祖先是结点2，即LCA（3 4）=2 。在此，需要注意到当两个结点在同一棵子树上的情况，如结点3和结点2的最近公共祖先为2，即 LCA（3，2）=2。同理：LCA（5，6）=4，LCA（6，10）=1。</p>
<p>明确了题意，咱们便来试着解决这个问题。直观的做法，可能是针对是否为二叉查找树分情况讨论，这也是一般人最先想到的思路。除此之外，还有所谓的Tarjan算法、倍增算法、以及转换为RMQ问题（求某段区间的极值）。后面这几种算法相对高级，不那么直观，但思路比较有启发性，了解一下也有裨益。</p>
<h3 id="解法一：暴力对待">解法一：暴力对待</h3>
<h4 id="1-1、是二叉查找树">1.1、是二叉查找树</h4>
<p>在当这棵树是二叉查找树的情况下，如下图：</p>
<p><img src="../images/39/39.2.jpg" alt=""></p>
<p>那么从树根开始：</p>
<ul>
<li>如果当前结点t 大于结点u、v，说明u、v都在t 的左侧，所以它们的共同祖先必定在t 的左子树中，故从t 的左子树中继续查找；</li>
<li>如果当前结点t 小于结点u、v，说明u、v都在t 的右侧，所以它们的共同祖先必定在t 的右子树中，故从t 的右子树中继续查找；</li>
<li>如果当前结点t 满足 u &lt;t &lt; v，说明u和v分居在t 的两侧，故当前结点t 即为最近公共祖先；</li>
<li>而如果u是v的祖先，那么返回u的父结点，同理，如果v是u的祖先，那么返回v的父结点。</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//copyright@eriol 2011  </span></div><div class="line"><span class="comment">//modified by July 2014  </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> query(Node t, Node u, Node v) {    </div><div class="line">    <span class="keyword">int</span> left = u.value;    </div><div class="line">    <span class="keyword">int</span> right = v.value;    </div><div class="line">    Node parent = null;    </div><div class="line">  </div><div class="line">    <span class="comment">//二叉查找树内，如果左结点大于右结点，不对，交换  </span></div><div class="line">    <span class="keyword">if</span> (left &gt; right) {    </div><div class="line">        <span class="keyword">int</span> temp = left;    </div><div class="line">        left = right;    </div><div class="line">        right = temp;    </div><div class="line">    }    </div><div class="line">  </div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {    </div><div class="line">        <span class="comment">//如果t小于u、v，往t的右子树中查找  </span></div><div class="line">        <span class="keyword">if</span> (t.value &lt; left) {    </div><div class="line">            parent = t;    </div><div class="line">            t = t.right;    </div><div class="line">  </div><div class="line">        <span class="comment">//如果t大于u、v，往t的左子树中查找  </span></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (t.value &gt; right) {    </div><div class="line">            parent = t;    </div><div class="line">            t = t.left;    </div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (t.value == left || t.value == right) {    </div><div class="line">            <span class="keyword">return</span> parent.value;    </div><div class="line">        } <span class="keyword">else</span> {    </div><div class="line">            <span class="keyword">return</span> t.value;    </div><div class="line">        }    </div><div class="line">    }    </div><div class="line">}</div></pre></td></tr></table></figure>


<h4 id="1-2、不是二叉查找树">1.2、不是二叉查找树</h4>
<p>但如果这棵树不是二叉查找树，只是一棵普通的二叉树呢？如果每个结点都有一个指针指向它的父结点，于是我们可以从任何一个结点出发，得到一个到达树根结点的单向链表。因此这个问题转换为两个单向链表的第一个公共结点。</p>
<p>此外，如果给出根节点，LCA问题可以用递归很快解决。而关于树的问题一般都可以转换为递归（因为树本来就是递归描述），参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//copyright@allantop 2014-1-22-20:01  </span></div><div class="line">node* getLCA(node* root, node* node1, node* node2)  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(root == null)  </div><div class="line">        <span class="keyword">return</span> null;  </div><div class="line">    <span class="keyword">if</span>(root== node1 || root==node2)  </div><div class="line">        <span class="keyword">return</span> root;  </div><div class="line">  </div><div class="line">    node* left = getLCA(root-&gt;left, node1, node2);  </div><div class="line">    node* right = getLCA(root-&gt;right, node1, node2);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span>(left != null && right != null)  </div><div class="line">        <span class="keyword">return</span> root;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left != null)  </div><div class="line">        <span class="keyword">return</span> left;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right != null)  </div><div class="line">        <span class="keyword">return</span> right;  </div><div class="line">    <span class="keyword">else</span>   </div><div class="line">        <span class="keyword">return</span> null;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>然不论是针对普通的二叉树，还是针对二叉查找树，上面的解法有一个很大的弊端就是：如需N 次查询，则总体复杂度会扩大N 倍，故这种暴力解法仅适合一次查询，不适合多次查询。</p>
<p>接下来的解法，将不再区别对待是否为二叉查找树，而是一致当做是一棵普通的二叉树。总体来说，由于可以把LCA问题看成是询问式的，即给出一系列询问，程序对每一个询问尽快做出反应。故处理这类问题一般有两种解决方法：</p>
<ul>
<li>一种是在线算法，相当于循序渐进处理；</li>
<li>另外一种则是离线算法，如Tarjan算法，相当于一次性批量处理，一开始就知道了全部查询，只待询问。</li>
</ul>
<h3 id="解法二：Tarjan算法">解法二：Tarjan算法</h3>
<p>如上文末节所述，不论咱们所面对的二叉树是二叉查找树，或不是二叉查找树，都可以把求任意两个结点的最近公共祖先，当做是查询的问题，如果是只求一次，则是单次查询；如果要求多个任意两个结点的最近公共祖先，则相当于是批量查询。</p>
<p>涉及到批量查询的时候，咱们可以借鉴离线处理的方式，这就引出了解决此LCA问题的Tarjan离线算法。</p>
<h4 id="2-1、什么是Tarjan算法">2.1、什么是Tarjan算法</h4>
<p>Tarjan算法 （以发现者Robert Tarjan命名）是一个在图中寻找强连通分量的算法。算法的基本思想为：任选一结点开始进行深度优先搜索dfs（若深度优先搜索结束后仍有未访问的结点，则再从中任选一点再次进行）。搜索过程中已访问的结点不再访问。搜索树的若干子树构成了图的强连通分量。</p>
<p>应用到咱们要解决的LCA问题上，则是：对于新搜索到的一个结点u，先创建由u构成的集合，再对u的每颗子树进行搜索，每搜索完一棵子树，这时候子树中所有的结点的最近公共祖先就是u了。</p>
<p>举一个例子，如下图（不同颜色的结点相当于不同的集合）：</p>
<p><img src="../images/39/39.3.jpg" alt=""></p>
<p>假设遍历完10的孩子,要处理关于10的请求了，取根节点到当前正在遍历的节点的路径为关键路径,即1-3-8-10，集合的祖先便是关键路径上距离集合最近的点。</p>
<p>比如：</p>
<ul>
<li>1，2，5，6为一个集合,祖先为1，集合中点和10的LCA为1</li>
<li>3，7为一个集合，祖先为3，集合中点和10的LCA为3</li>
<li>8，9，11为一个集合，祖先为8，集合中点和10的LCA为8</li>
<li>10，12为一个集合，祖先为10，集合中点和10的LCA为10</li>
</ul>
<p>得出的结论便是：LCA(u,v)便是根至u的路径上到节点v最近的点。</p>
<h4 id="2-2、Tarjan算法如何而来">2.2、Tarjan算法如何而来</h4>
<p>但关键是 Tarjan算法是怎么想出来的呢？再给定下图，你是否能看出来：分别从结点1的左右子树当中，任取一个结点，设为u、v，这两个任意结点u、v的最近公共祖先都为1。</p>
<p><img src="../images/39/39.4.jpg" alt=""></p>
<p>于此，我们可以得知：若两个结点u、v分别分布于某节点t 的左右子树，那么此节点 t即为u和v的最近公共祖先。更进一步，考虑到一个节点自己就是LCA的情况，得知：</p>
<ul>
<li>若某结点t 是两结点u、v的祖先之一，且这两结点并不分布于该结点t 的一棵子树中，而是分别在结点t 的左子树、右子树中，那么该结点t 即为两结点u、v的最近公共祖先。</li>
</ul>
<p>这个定理就是Tarjan算法的基础。</p>
<p>一如上文1.1节我们得到的结论：“如果当前结点t 满足 u &lt;t &lt; v，说明u和v分居在t 的两侧，故当前结点t 即为最近公共祖先”。</p>
<p>而对于本节开头我们所说的“如果要求多个任意两个结点的最近公共祖先，则相当于是批量查询”，即在很多组的询问的情况下，或许可以先确定一个LCA。例如是根节点1，然后再去检查所有询问，看是否满足刚才的定理，不满足就忽视，满足就赋值，全部弄完，再去假设2号节点是LCA，再去访问一遍。</p>
<p>可此方法需要判断一个结点是在左子树、还是右子树，或是都不在，都只能遍历一棵树，而多次遍历的代价实在是太大了，所以我们需要找到更好的方法。这就引出了下面要阐述的Tarjan算法，即每个结点只遍历一次，怎么做到的呢，请看下文讲解。</p>
<h3 id="2-3、Tarjan算法流程">2.3、Tarjan算法流程</h3>
<p>Tarjan算法流程为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">dfs</span>（<span class="title">u</span>）；</span></div><div class="line">	<span class="title">begin</span></div><div class="line">		设置<span class="title">u</span>号节点的祖先为<span class="title">u</span></div><div class="line">		若<span class="title">u</span>的左子树不为空，<span class="title">dfs</span>（<span class="title">u</span> - 左子树）；</div><div class="line">		若<span class="title">u</span>的右子树不为空，<span class="title">dfs</span>（<span class="title">u</span> - 右子树）；</div><div class="line">		访问每一条与<span class="title">u</span>相关的询问<span class="title">u</span>、<span class="title">v</span></div><div class="line">			-若<span class="title">v</span>已经被访问过，则输出<span class="title">v</span>当前的祖先<span class="title">t</span>（<span class="title">t</span>即<span class="title">u</span>,<span class="title">v</span>的<span class="title">LCA</span>）</div><div class="line">		标记<span class="title">u</span>为已经访问，将所有<span class="title">u</span>的孩子包括<span class="title">u</span>本身的祖先改为<span class="title">u</span>的父亲</div><div class="line">	<span class="title">end</span></div></pre></td></tr></table></figure>

<p>普通的dfs 不能直接解决LCA问题，故Tarjan算法的原理是dfs + <a href="http://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="external">并查集</a>，它每次把两个结点对的最近公共祖先的查询保存起来，然后dfs 更新一次。如此，利用并查集优越的时空复杂度，此算法的时间复杂度可以缩小至O(n＋Q)，其中，n为数据规模，Q为询问个数。</p>
<h3 id="解法三：转换为RMQ问题">解法三：转换为RMQ问题</h3>
<p>解决此最近公共祖先问题的还有一个算法，即转换为RMQ问题，用Sparse Table（简称ST）算法解决。</p>
<h3 id="3-1、什么是RMQ问题">3.1、什么是RMQ问题</h3>
<p>RMQ，全称为Range Minimum Query，顾名思义，则是区间最值查询，它被用来在数组中查找两个指定索引中最小值的位置。即RMQ相当于给定数组A[0, N-1]，找出给定的两个索引如 i、j 间的最小值的位置。</p>
<p>假设一个算法预处理时间为 f(n)，查询时间为g(n)，那么这个算法复杂度的标记为<f(n), g(n)="">。我们将用RMQA(i, j) 来表示数组A 中索引i 和 j 之间最小值的位置。 u和v的离树T根结点最远的公共祖先用LCA T(u, v)表示。</f(n),></p>
<p>如下图所示，RMQA(2,7 )则表示求数组A中从A[2]~A[7]这段区间中的最小值：</p>
<p><img src="../images/39/39.31.jpg" alt=""></p>
<p>很显然，从上图中，我们可以看出最小值是A[3] = 1，所以也就不难得出最小值的索引值RMQA(2,7) = 3。</p>
<h4 id="3-2、如何解决RMQ问题">3.2、如何解决RMQ问题</h4>
<h5 id="3-2-1、Trivial_algorithms_for_RMQ">3.2.1、Trivial algorithms for RMQ</h5>
<p>下面，我们对对每一对索引(i, j)，将数组中索引i 和 j 之间最小值的位置 RMQA(i, j) 存储在M[0, N-1][0, N-1]表中。 RMQA(i, j) 有不同种计算方法，你会看到，随着计算方法的不同，它的时空复杂度也不同：</p>
<ul>
<li>普通的计算将得到一个<o(n^3), o(1)=""> 复杂度的算法。尽管如此，通过使用一个简单的动态规划方法，我们可以将复杂度降低到<o(n^2), o(1)="">。如何做到的呢？方法如下代码所示：</o(n^2),></o(n^3),></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//copyright@  </span></div><div class="line"><span class="comment">//modified by July 2014  </span></div><div class="line"><span class="keyword">void</span> process1(<span class="keyword">int</span> M[MAXN][MAXN], <span class="keyword">int</span> A[MAXN], <span class="keyword">int</span> N)  </div><div class="line">{  </div><div class="line">    <span class="keyword">int</span> i, j;  </div><div class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; N; i++)  </div><div class="line">        M[i][i] = i;  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)  </div><div class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; N; j++)  </div><div class="line">            <span class="comment">//若前者小于后者，则把后者的索引值付给M[i][j]  </span></div><div class="line">            <span class="keyword">if</span> (A[M[i][j - <span class="number">1</span>]] &lt; A[j])  </div><div class="line">                M[i][j] = M[i][j - <span class="number">1</span>];  </div><div class="line">            <span class="comment">//否则前者的索引值付给M[i][j]  </span></div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                M[i][j] = j;  </div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>一个比较有趣的点子是把向量分割成sqrt(N)大小的段。我们将在M[0,sqrt(N)-1]为每一个段保存最小值的位置。如此，M可以很容易的在O(N)时间内预处理。</li>
</ul>
<p><img src="../images/39/39.32.jpg" alt=""></p>
<ul>
<li>一个更好的方法预处理RMQ 是对2^k 的长度的子数组进行动态规划。我们将使用数组M[0, N-1][0, logN]进行保存，其中M[ i ][ j ] 是以i 开始，长度为 2^j 的子数组的最小值的索引。这就引出了咱们接下来要介绍的Sparse Table (ST) algorithm。</li>
</ul>
<h5 id="3-2-2、Sparse_Table_(ST)_algorithm">3.2.2、Sparse Table (ST) algorithm</h5>
<p><img src="../images/39/39.33.jpg" alt=""></p>
<p>在上图中，我们可以看出：</p>
<ul>
<li>在A[1]这个长度为2^0的区间内，最小值即为A[1] = 4，故最小值的索引M[1][0]为1；</li>
<li>在A[1]、A[2] 这个长度为2^1的区间内，最小值为A[2] = 3，故最小值的索引为M[1][1] = 2；</li>
<li>在A[1]、A[2]、A[3]、A[4]这个长度为2^2的区间内，最小值为A[3] = 1，故最小值的索引M[1][2] = 3。</li>
</ul>
<p>为了计算M[i][j]我们必须找到前半段区间和后半段区间的最小值。很明显小的片段有着2^(j-1)长度，因此递归如下  </p>
<p><img src="../images/39/39.34.jpg" alt=""></p>
<p>根据上述公式，可以写出这个预处理的递归代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> process2(<span class="keyword">int</span> M[MAXN][LOGMAXN], <span class="keyword">int</span> A[MAXN], <span class="keyword">int</span> N)  </div><div class="line">{  </div><div class="line">    <span class="keyword">int</span> i, j;  </div><div class="line">    <span class="comment">//initialize M for the intervals with length 1  </span></div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)  </div><div class="line">        M[i][<span class="number">0</span>] = i;  </div><div class="line">  </div><div class="line">    <span class="comment">//compute values from smaller to bigger intervals  </span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; j &lt;= N; j++)  </div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; N; i++)  </div><div class="line">            <span class="keyword">if</span> (A[M[i][j - <span class="number">1</span>]] &lt; A[M[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]])  </div><div class="line">                M[i][j] = M[i][j - <span class="number">1</span>];  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                M[i][j] = M[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>经过这个O(N logN)时间复杂度的预处理之后，让我们看看怎样使用它们去计算 RMQA(i, j)。思路是选择两个能够完全覆盖区间[i..j]的块并且找到它们之间的最小值。设k = [log(j - i + 1)]。</p>
<p>为了计算 RMQA(i, j)，我们可以使用下面的公式：</p>
<p><img src="../images/39/39.35.jpg" alt=""></p>
<p>故，综合来看，咱们预处理的时间复杂度从O(N3)降低到了O(N logN)，查询的时间复杂度为O(1)，所以最终的整体复杂度为：&lt; O(N logN), O(1) &gt;。</p>
<h4 id="3-3、LCA与RMQ的关联性">3.3、LCA与RMQ的关联性</h4>
<p>现在，让我们看看怎样用RMQ来计算LCA查询。事实上，我们可以在线性时间里将LCA问题规约到RMQ问题，因此每一个解决RMQ的问题都可以解决LCA问题。让我们通过例子来说明怎么规约的：</p>
<p><img src="../images/39/39.37.jpg" alt=""> </p>
<p><img src="../images/39/39.38.jpg" alt=""></p>
<p>注意LCAT(u, v)是在对T进行dfs过程当中在访问u和v之间离根结点最近的点。因此我们可以考虑树的欧拉环游过程u和v之间所有的结点，并找到它们之间处于最低层的结点。为了达到这个目的，我们可以建立三个数组：</p>
<ul>
<li>E[1, 2*N-1]  - 对T进行欧拉环游过程中所有访问到的结点;E[i]是在环游过程中第i个访问的结点</li>
<li>L[1,2*N-1] -  欧拉环游中访问到的结点所处的层数;L[i]是E[i]所在的层数</li>
<li>H[1, N] - H[i] 是E中结点i第一次出现的下标(任何出现i的地方都行，当然选第一个不会错)</li>
</ul>
<p>假定H[u]&lt;H<a href="否则你要交换u和v">v</a>。可以很容易的看到u和v第一次出现的结点是E[H[u]..H[v]]。现在，我们需要找到这些结点中的最低层。为了达到这个目的，我们可以使用RMQ。因此 LCAT(u, v) = E[RMQL(H[u], H[v])] ,RMQ返回的是索引，下面是E,L,H数组：</p>
<p><img src="../images/39/39.39.jpg" alt=""></p>
<p>注意L中连续的元素相差为1。</p>
<h3 id="3-4、从RMQ到LCA">3.4、从RMQ到LCA</h3>
<p>我们已经看到了LCA问题可以在线性时间规约到RMQ问题。现在让我们来看看怎样把RMQ问题规约到LCA。这个意味着我们实际上可以把一般的RMQ问题规约到带约束的RMQ问题(这里相邻的元素相差1)。为了达到这个目的，我们需要使用笛卡尔树。</p>
<p>对于数组A[0,N-1]的笛卡尔树C(A)是一个二叉树，根节点是A的最小元素，假设i为A数组中最小元素的位置。当i&gt;0时，这个笛卡尔树的左子结点是A[0,i-1]构成的笛卡尔树，其他情况没有左子结点。右结点类似的用A[i+1,N-1]定义。注意对于具有相同元素的数组A，笛卡尔树并不唯一。在本文中，将会使用第一次出现的最小值，因此笛卡尔树看作唯一。可以很容易的看到RMQA(i, j) = LCAC(i, j)。</p>
<p>下面是一个例子：</p>
<p><img src="../images/39/39.40.jpg" alt=""></p>
<p><img src="../images/39/39.41.jpg" alt=""></p>
<p>现在我们需要做的仅仅是用线性时间计算C(A)。这个可以使用栈来实现。</p>
<ul>
<li>初始栈为空。</li>
<li>然后我们在栈中插入A的元素。</li>
<li>在第i步,A[i]将会紧挨着栈中比A[i]小或者相等的元素插入,并且所有较大的元素将会被移除。</li>
<li>在插入结束之前栈中A[i]位置前的元素将成为i的左儿子，A[i]将会成为它之后一个较小元素的右儿子。</li>
</ul>
<p>在每一步中，栈中的第一个元素总是笛卡尔树的根。</p>
<p>如果使用栈来保存元素的索引而不是值，我们可以很轻松的建立树。由于A中的每个元素最多被增加一次和最多被移除一次，所以建树的时间复杂度为O(N)。最终查询的时间复杂度为O(1)，故综上可得，咱们整个问题的最终时间复杂度为：<o(n), o(1)="">。</o(n),></p>
<p>现在，对于询问 RMQA(i, j) 我们有两种情况:</p>
<ul>
<li>i和j在同一个块中,因此我们使用在P和T中计算的值 </li>
<li>i和j在不同的块中，因此我们计算三个值:从i到i所在块的末尾的P和T中的最小值，所有i和j中块中的通过与处理得到的最小值以及从j所在块i和j在同一个块中,因此我们使用在P和T中计算的值j的P和T的最小值；最后我们我们只要计算三个值中最小值的位置即可。</li>
</ul>
<p>RMQ和LCA是密切相关的问题，因为它们之间可以相互规约。有许多算法可以用来解决它们，并且他们适应于一类问题。</p>
<h3 id="解法四：线段树">解法四：线段树</h3>
<p>解决RMQ问题也可以用所谓的线段树Segment trees。线段树是一个类似堆的数据结构，可以在基于区间数组上用对数时间进行更新和查询操作。我们用下面递归方式来定义线段树的[i, j]区间：</p>
<ul>
<li>第一个结点将保存区间[i, j]区间的信息</li>
<li>如果i&lt;j 左右的孩子结点将保存区间[i, (i+j)/2]和[(i+j)/2+1, j] 的信息</li>
</ul>
<p>注意具有N个区间元素的线段树的高度为[logN] + 1。下面是区间[0,9]的线段树：</p>
<p><img src="../images/39/39.36.jpg" alt=""></p>
<p>线段树和堆具有相同的结构，因此我们定义x是一个非叶结点，那么左孩子结点为2<em>x,而右孩子结点为2</em>x+1。想要使用线段树解决RMQ问题，我们则要要使用数组 M[1, 2 * 2[logN] + 1]，这里M[i]保存结点i区间最小值的位置。初始时M的所有元素为-1。树应当用下面的函数进行初始化(b和e是当前区间的范围)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> initialize(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> M[MAXIND], <span class="keyword">int</span> A[MAXN], <span class="keyword">int</span> N)  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span> (b == e)  </div><div class="line">        M[node] = b;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    {  </div><div class="line">        <span class="comment">//compute the values in the left and right subtrees  </span></div><div class="line">        initialize(<span class="number">2</span> * node, b, (b + e) / <span class="number">2</span>, M, A, N);  </div><div class="line">        initialize(<span class="number">2</span> * node + <span class="number">1</span>, (b + e) / <span class="number">2</span> + <span class="number">1</span>, e, M, A, N);  </div><div class="line">  </div><div class="line">        <span class="comment">//search for the minimum value in the first and  </span></div><div class="line">        <span class="comment">//second half of the interval  </span></div><div class="line">        <span class="keyword">if</span> (A[M[<span class="number">2</span> * node]] &lt;= A[M[<span class="number">2</span> * node + <span class="number">1</span>]])  </div><div class="line">            M[node] = M[<span class="number">2</span> * node];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            M[node] = M[<span class="number">2</span> * node + <span class="number">1</span>];  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的函数映射出了这棵树建造的方式。当计算一些区间的最小值位置时，我们应当首先查看子结点的值。调用函数的时候使用 node = 1, b = 0和e  = N-1。</p>
<p>现在我们可以开始进行查询了。如果我们想要查找区间[i, j]中的最小值的位置时，我们可以使用下一个简单的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> query(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> M[MAXIND], <span class="keyword">int</span> A[MAXN], <span class="keyword">int</span> i, <span class="keyword">int</span> j)  </div><div class="line">{  </div><div class="line">    <span class="keyword">int</span> p1, p2;  </div><div class="line">    <span class="comment">//if the current interval doesn't intersect  </span></div><div class="line">    <span class="comment">//the query interval return -1  </span></div><div class="line">    <span class="keyword">if</span> (i &gt; e || j &lt; b)  </div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//if the current interval is included in  </span></div><div class="line">    <span class="comment">//the query interval return M[node]  </span></div><div class="line">    <span class="keyword">if</span> (b &gt;= i && e &lt;= j)  </div><div class="line">        <span class="keyword">return</span> M[node];  </div><div class="line">  </div><div class="line">    <span class="comment">//compute the minimum position in the  </span></div><div class="line">    <span class="comment">//left and right part of the interval  </span></div><div class="line">    p1 = query(<span class="number">2</span> * node, b, (b + e) / <span class="number">2</span>, M, A, i, j);  </div><div class="line">    p2 = query(<span class="number">2</span> * node + <span class="number">1</span>, (b + e) / <span class="number">2</span> + <span class="number">1</span>, e, M, A, i, j);  </div><div class="line">  </div><div class="line">    <span class="comment">//return the position where the overall  </span></div><div class="line">    <span class="comment">//minimum is  </span></div><div class="line">    <span class="keyword">if</span> (p1 == -<span class="number">1</span>)  </div><div class="line">        <span class="keyword">return</span> M[node] = p2;  </div><div class="line">    <span class="keyword">if</span> (p2 == -<span class="number">1</span>)  </div><div class="line">        <span class="keyword">return</span> M[node] = p1;  </div><div class="line">    <span class="keyword">if</span> (A[p1] &lt;= A[p2])  </div><div class="line">        <span class="keyword">return</span> M[node] = p1;  </div><div class="line">    <span class="keyword">return</span> M[node] = p2;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>你应该使用node = 1, b = 0和e = N - 1来调用这个函数，因为分配给第一个结点的区间是[0, N-1]。</p>
<p>可以很容易的看出任何查询都可以在O(log N)内完成。注意当我们碰到完整的in/out区间时我们停止了，因此数中的路径最多分裂一次。用线段树我们获得了<o(n),o(logn)>的算法</o(n),o(logn)></p>
<p>线段树非常强大，不仅仅是因为它能够用在RMQ上，还因为它是一个非常灵活的数据结构，它能够解决动态版本的RMQ问题和大量的区间搜索问题。</p>
<h3 id="其余解法">其余解法</h3>
<p>除此之外，还有倍增法、重链剖分算法和后序遍历也可以解决该问题。其中，倍增思路相当于层序遍历，逐层或几层跳跃查，查询时间复杂度为O(log n)，空间复杂度为nlogn，对于每个节点先存储向上1层2层4层的节点，每个点有depth信息。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>


<div class="article-share" id="share">

  <div data-url="http://qiaoidea.github.io/programing_art/ebook/zh/03.03.html" data-title="Qiaoidea&#39;s Blog" data-tsina="5288126184" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
	
<section id="comments" class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
        </div>
        <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 一时不学，差之毫厘； <br/>
			终日不学，失之千里。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5288126184" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2015 
		
		<a href="http://qiaoidea.github.io/about" target="_blank" title="Qiaoidea">Qiaoidea</a>
		
		</p>
</div>
</footer>
        <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"qiaoidea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

      </body>
     </html>
     
