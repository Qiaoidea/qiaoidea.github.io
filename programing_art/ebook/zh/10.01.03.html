
  
    <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Qiaoidea&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Qiaoidea">
    
    <meta name="description" content="Android">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Qiaoidea&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

      <body>
        <header>
          <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiaoidea&#39;s Blog" title="Qiaoidea&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiaoidea&#39;s Blog">Qiaoidea&#39;s Blog</a></h1>
				<h2 class="blog-motto">你必须非常努力，才能看起来毫不费力。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/dj">札记</a></li>
					
						<li><a href="/programing_art">编程艺术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qiaoidea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
        </header>
        <div id="container">
          <div id="main" class="page" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/programing_art/ebook/zh/10.01.03.html" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="http://qiaoidea.github.io/about" title="Qiaoidea" target="_blank" itemprop="author">Qiaoidea</a>
		
  <p class="article-time">
    <time datetime="2015-01-10T11:57:47.000Z" itemprop="datePublished"> 发表于 1月 10 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="教你一步一步用c语言实现sift算法、下">教你一步一步用c语言实现sift算法、下</h1>
<p>本文接上，<a href="10.01.02.md">教你一步一步用c语言实现sift算法、上</a>而来：</p>
<h3 id="函数编写"><strong>函数编写</strong></h3>
<p>ok，接上文，咱们一个一个的来编写main函数中所涉及到所有函数，这也是本文的关键部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下采样原来的图像，返回缩小2倍尺寸的图像  </span></div><div class="line">CvMat * halfSizeImage(CvMat * im)   </div><div class="line">{  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;  </div><div class="line">	<span class="keyword">int</span> w = im-&gt;cols/<span class="number">2</span>;  </div><div class="line">	<span class="keyword">int</span> h = im-&gt;rows/<span class="number">2</span>;   </div><div class="line">	CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; h; j++)   </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; w; i++)   </div><div class="line">			Imnew(j,i)=Im(j*<span class="number">2</span>, i*<span class="number">2</span>);  </div><div class="line">	<span class="keyword">return</span> imnew;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//上采样原来的图像，返回放大2倍尺寸的图像  </span></div><div class="line">CvMat * doubleSizeImage(CvMat * im)   </div><div class="line">{  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;  </div><div class="line">	<span class="keyword">int</span> w = im-&gt;cols*<span class="number">2</span>;  </div><div class="line">	<span class="keyword">int</span> h = im-&gt;rows*<span class="number">2</span>;   </div><div class="line">	CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; h; j++)   </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; w; i++)   </div><div class="line">			Imnew(j,i)=Im(j/<span class="number">2</span>, i/<span class="number">2</span>);  </div><div class="line"></div><div class="line">	<span class="keyword">return</span> imnew;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//上采样原来的图像，返回放大2倍尺寸的线性插值图像  </span></div><div class="line">CvMat * doubleSizeImage2(CvMat * im)   </div><div class="line">{  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;  </div><div class="line">	<span class="keyword">int</span> w = im-&gt;cols*<span class="number">2</span>;  </div><div class="line">	<span class="keyword">int</span> h = im-&gt;rows*<span class="number">2</span>;   </div><div class="line">	CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	<span class="comment">// fill every pixel so we don't have to worry about skipping pixels later  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; h; j++)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; w; i++)   </div><div class="line">		{  </div><div class="line">			Imnew(j,i)=Im(j/<span class="number">2</span>, i/<span class="number">2</span>);  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="comment">/* </span></div><div class="line">	A B C </div><div class="line">	E F G </div><div class="line">	H I J </div><div class="line">	pixels A C H J are pixels from original image </div><div class="line">	pixels B E G I F are interpolated pixels </div><div class="line">	*/  </div><div class="line">	<span class="comment">// interpolate pixels B and I  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; h; j += <span class="number">2</span>)  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; w - <span class="number">1</span>; i += <span class="number">2</span>)  </div><div class="line">			Imnew(j,i)=<span class="number">0.5</span>*(Im(j/<span class="number">2</span>, i/<span class="number">2</span>)+Im(j/<span class="number">2</span>, i/<span class="number">2</span>+<span class="number">1</span>));  </div><div class="line">	<span class="comment">// interpolate pixels E and G  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt; h - <span class="number">1</span>; j += <span class="number">2</span>)  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; w; i += <span class="number">2</span>)  </div><div class="line">			Imnew(j,i)=<span class="number">0.5</span>*(Im(j/<span class="number">2</span>, i/<span class="number">2</span>)+Im(j/<span class="number">2</span>+<span class="number">1</span>, i/<span class="number">2</span>));  </div><div class="line">	<span class="comment">// interpolate pixel F  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt; h - <span class="number">1</span>; j += <span class="number">2</span>)  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; w - <span class="number">1</span>; i += <span class="number">2</span>)  </div><div class="line">			Imnew(j,i)=<span class="number">0.25</span>*(Im(j/<span class="number">2</span>, i/<span class="number">2</span>)+Im(j/<span class="number">2</span>+<span class="number">1</span>, i/<span class="number">2</span>)+Im(j/<span class="number">2</span>, i/<span class="number">2</span>+<span class="number">1</span>)+Im(j/<span class="number">2</span>+<span class="number">1</span>, i/<span class="number">2</span>+<span class="number">1</span>));  </div><div class="line">	<span class="keyword">return</span> imnew;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//双线性插值，返回像素间的灰度值  </span></div><div class="line"><span class="keyword">float</span> getPixelBI(CvMat * im, <span class="keyword">float</span> col, <span class="keyword">float</span> row)   </div><div class="line">{  </div><div class="line">	<span class="keyword">int</span> irow, icol;  </div><div class="line">	<span class="keyword">float</span> rfrac, cfrac;  </div><div class="line">	<span class="keyword">float</span> row1 = <span class="number">0</span>, row2 = <span class="number">0</span>;  </div><div class="line">	<span class="keyword">int</span> width=im-&gt;cols;  </div><div class="line">	<span class="keyword">int</span> height=im-&gt;rows;  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ImMat(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	irow = (<span class="keyword">int</span>) row;  </div><div class="line">	icol = (<span class="keyword">int</span>) col;  </div><div class="line"></div><div class="line">	<span class="keyword">if</span> (irow &lt; <span class="number">0</span> || irow &gt;= height  </div><div class="line">		|| icol &lt; <span class="number">0</span> || icol &gt;= width)  </div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">	<span class="keyword">if</span> (row &gt; height - <span class="number">1</span>)  </div><div class="line">		row = height - <span class="number">1</span>;  </div><div class="line">	<span class="keyword">if</span> (col &gt; width - <span class="number">1</span>)  </div><div class="line">		col = width - <span class="number">1</span>;  </div><div class="line">	rfrac = <span class="number">1.0</span> - (row - (<span class="keyword">float</span>) irow);  </div><div class="line">	cfrac = <span class="number">1.0</span> - (col - (<span class="keyword">float</span>) icol);  </div><div class="line">	<span class="keyword">if</span> (cfrac &lt; <span class="number">1</span>)   </div><div class="line">	{  </div><div class="line">		row1 = cfrac * ImMat(irow,icol) + (<span class="number">1.0</span> - cfrac) * ImMat(irow,icol+<span class="number">1</span>);  </div><div class="line">	}   </div><div class="line">	<span class="keyword">else</span>   </div><div class="line">	{  </div><div class="line">		row1 = ImMat(irow,icol);  </div><div class="line">	}  </div><div class="line">	<span class="keyword">if</span> (rfrac &lt; <span class="number">1</span>)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">if</span> (cfrac &lt; <span class="number">1</span>)   </div><div class="line">		{  </div><div class="line">			row2 = cfrac * ImMat(irow+<span class="number">1</span>,icol) + (<span class="number">1.0</span> - cfrac) * ImMat(irow+<span class="number">1</span>,icol+<span class="number">1</span>);  </div><div class="line">		} <span class="keyword">else</span>   </div><div class="line">		{  </div><div class="line">			row2 = ImMat(irow+<span class="number">1</span>,icol);  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="keyword">return</span> rfrac * row1 + (<span class="number">1.0</span> - rfrac) * row2;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//矩阵归一化  </span></div><div class="line"><span class="keyword">void</span> normalizeMat(CvMat* mat)   </div><div class="line">{  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">float</span> sum = <span class="number">0</span>;  </div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat-&gt;rows; j++)   </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;cols; i++)   </div><div class="line">			sum += Mat(j,i);  </div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; mat-&gt;rows; j++)   </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;rows; i++)   </div><div class="line">			Mat(j,i) /= sum;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//向量归一化  </span></div><div class="line"><span class="keyword">void</span> normalizeVec(<span class="keyword">float</span>* vec, <span class="keyword">int</span> dim)   </div><div class="line">{  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;  </div><div class="line">	<span class="keyword">float</span> sum = <span class="number">0</span>;  </div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dim; i++)  </div><div class="line">		sum += vec[i];  </div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dim; i++)  </div><div class="line">		vec[i] /= sum;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//得到向量的欧式长度，2-范数  </span></div><div class="line"><span class="keyword">float</span> GetVecNorm( <span class="keyword">float</span>* vec, <span class="keyword">int</span> dim )  </div><div class="line">{  </div><div class="line">	<span class="keyword">float</span> sum=<span class="number">0.0</span>;  </div><div class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dim;i++)  </div><div class="line">		sum+=vec[i]*vec[i];  </div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(sum);  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//产生1D高斯核  </span></div><div class="line"><span class="keyword">float</span>* GaussianKernel1D(<span class="keyword">float</span> sigma, <span class="keyword">int</span> dim)   </div><div class="line">{  </div><div class="line"></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;  </div><div class="line">	<span class="comment">//printf("GaussianKernel1D(): Creating 1x%d vector for sigma=%.3f gaussian kernel/n", dim, sigma);  </span></div><div class="line"></div><div class="line">	<span class="keyword">float</span> *kern=(<span class="keyword">float</span>*)<span class="built_in">malloc</span>( dim*<span class="keyword">sizeof</span>(<span class="keyword">float</span>) );  </div><div class="line">	<span class="keyword">float</span> s2 = sigma * sigma;  </div><div class="line">	<span class="keyword">int</span> c = dim / <span class="number">2</span>;  </div><div class="line">	<span class="keyword">float</span> m= <span class="number">1.0</span>/(<span class="built_in">sqrt</span>(<span class="number">2.0</span> * CV_PI) * sigma);  </div><div class="line">	<span class="keyword">double</span> v;   </div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (dim + <span class="number">1</span>) / <span class="number">2</span>; i++)   </div><div class="line">	{  </div><div class="line">		v = m * <span class="built_in">exp</span>(-(<span class="number">1.0</span>*i*i)/(<span class="number">2.0</span> * s2)) ;  </div><div class="line">		kern[c+i] = v;  </div><div class="line">		kern[c-i] = v;  </div><div class="line">	}  </div><div class="line">	<span class="comment">//   normalizeVec(kern, dim);  </span></div><div class="line">	<span class="comment">// for ( i = 0; i &lt; dim; i++)  </span></div><div class="line">	<span class="comment">//  printf("%f  ", kern[i]);  </span></div><div class="line">	<span class="comment">//  printf("/n");  </span></div><div class="line">	<span class="keyword">return</span> kern;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//产生2D高斯核矩阵  </span></div><div class="line">CvMat* GaussianKernel2D(<span class="keyword">float</span> sigma)   </div><div class="line">{  </div><div class="line">	<span class="comment">// int dim = (int) max(3.0f, GAUSSKERN * sigma);  </span></div><div class="line">	<span class="keyword">int</span> dim = (<span class="keyword">int</span>) max(<span class="number">3.0f</span>, <span class="number">2.0</span> * GAUSSKERN *sigma + <span class="number">1.0f</span>);  </div><div class="line">	<span class="comment">// make dim odd  </span></div><div class="line">	<span class="keyword">if</span> (dim % <span class="number">2</span> == <span class="number">0</span>)  </div><div class="line">		dim++;  </div><div class="line">	<span class="comment">//printf("GaussianKernel(): Creating %dx%d matrix for sigma=%.3f gaussian/n", dim, dim, sigma);  </span></div><div class="line">	CvMat* mat=cvCreateMat(dim, dim, CV_32FC1);  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">float</span> s2 = sigma * sigma;  </div><div class="line">	<span class="keyword">int</span> c = dim / <span class="number">2</span>;  </div><div class="line">	<span class="comment">//printf("%d %d/n", mat.size(), mat[0].size());  </span></div><div class="line">	<span class="keyword">float</span> m= <span class="number">1.0</span>/(<span class="built_in">sqrt</span>(<span class="number">2.0</span> * CV_PI) * sigma);  </div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (dim + <span class="number">1</span>) / <span class="number">2</span>; i++)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (dim + <span class="number">1</span>) / <span class="number">2</span>; j++)   </div><div class="line">		{  </div><div class="line">			<span class="comment">//printf("%d %d %d/n", c, i, j);  </span></div><div class="line">			<span class="keyword">float</span> v = m * <span class="built_in">exp</span>(-(<span class="number">1.0</span>*i*i + <span class="number">1.0</span>*j*j) / (<span class="number">2.0</span> * s2));  </div><div class="line">			Mat(c+i,c+j) =v;  </div><div class="line">			Mat(c-i,c+j) =v;  </div><div class="line">			Mat(c+i,c-j) =v;  </div><div class="line">			Mat(c-i,c-j) =v;  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="comment">// normalizeMat(mat);  </span></div><div class="line">	<span class="keyword">return</span> mat;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//x方向像素处作卷积  </span></div><div class="line"><span class="keyword">float</span> ConvolveLocWidth(<span class="keyword">float</span>* kernel, <span class="keyword">int</span> dim, CvMat * src, <span class="keyword">int</span> x, <span class="keyword">int</span> y)   </div><div class="line">{  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;  </div><div class="line">	<span class="keyword">float</span> pixel = <span class="number">0</span>;  </div><div class="line">	<span class="keyword">int</span> col;  </div><div class="line">	<span class="keyword">int</span> cen = dim / <span class="number">2</span>;  </div><div class="line">	<span class="comment">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span></div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dim; i++)   </div><div class="line">	{  </div><div class="line">		col = x + (i - cen);  </div><div class="line">		<span class="keyword">if</span> (col &lt; <span class="number">0</span>)  </div><div class="line">			col = <span class="number">0</span>;  </div><div class="line">		<span class="keyword">if</span> (col &gt;= src-&gt;cols)  </div><div class="line">			col = src-&gt;cols - <span class="number">1</span>;  </div><div class="line">		pixel += kernel[i] * Src(y,col);  </div><div class="line">	}  </div><div class="line">	<span class="keyword">if</span> (pixel &gt; <span class="number">1</span>)  </div><div class="line">		pixel = <span class="number">1</span>;  </div><div class="line">	<span class="keyword">return</span> pixel;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//x方向作卷积  </span></div><div class="line"><span class="keyword">void</span> Convolve1DWidth(<span class="keyword">float</span>* kern, <span class="keyword">int</span> dim, CvMat * src, CvMat * dst)   </div><div class="line">{  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> DST(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;  </div><div class="line"></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; src-&gt;rows; j++)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; src-&gt;cols; i++)   </div><div class="line">		{  </div><div class="line">			<span class="comment">//printf("%d, %d/n", i, j);  </span></div><div class="line">			DST(j,i) = ConvolveLocWidth(kern, dim, src, i, j);  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//y方向像素处作卷积  </span></div><div class="line"><span class="keyword">float</span> ConvolveLocHeight(<span class="keyword">float</span>* kernel, <span class="keyword">int</span> dim, CvMat * src, <span class="keyword">int</span> x, <span class="keyword">int</span> y)   </div><div class="line">{  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j;  </div><div class="line">	<span class="keyword">float</span> pixel = <span class="number">0</span>;  </div><div class="line">	<span class="keyword">int</span> cen = dim / <span class="number">2</span>;  </div><div class="line">	<span class="comment">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span></div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; dim; j++)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">int</span> row = y + (j - cen);  </div><div class="line">		<span class="keyword">if</span> (row &lt; <span class="number">0</span>)  </div><div class="line">			row = <span class="number">0</span>;  </div><div class="line">		<span class="keyword">if</span> (row &gt;= src-&gt;rows)  </div><div class="line">			row = src-&gt;rows - <span class="number">1</span>;  </div><div class="line">		pixel += kernel[j] * Src(row,x);  </div><div class="line">	}  </div><div class="line">	<span class="keyword">if</span> (pixel &gt; <span class="number">1</span>)  </div><div class="line">		pixel = <span class="number">1</span>;  </div><div class="line">	<span class="keyword">return</span> pixel;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//y方向作卷积  </span></div><div class="line"><span class="keyword">void</span> Convolve1DHeight(<span class="keyword">float</span>* kern, <span class="keyword">int</span> dim, CvMat * src, CvMat * dst)   </div><div class="line">{  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Dst(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;  </div><div class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; src-&gt;rows; j++)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; src-&gt;cols; i++)   </div><div class="line">		{  </div><div class="line">			<span class="comment">//printf("%d, %d/n", i, j);  </span></div><div class="line">			Dst(j,i) = ConvolveLocHeight(kern, dim, src, i, j);  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//卷积模糊图像  </span></div><div class="line"><span class="keyword">int</span> BlurImage(CvMat * src, CvMat * dst, <span class="keyword">float</span> sigma)   </div><div class="line">{  </div><div class="line">	<span class="keyword">float</span>* convkernel;  </div><div class="line">	<span class="keyword">int</span> dim = (<span class="keyword">int</span>) max(<span class="number">3.0f</span>, <span class="number">2.0</span> * GAUSSKERN * sigma + <span class="number">1.0f</span>);  </div><div class="line">	CvMat *tempMat;  </div><div class="line">	<span class="comment">// make dim odd  </span></div><div class="line">	<span class="keyword">if</span> (dim % <span class="number">2</span> == <span class="number">0</span>)  </div><div class="line">		dim++;  </div><div class="line">	tempMat = cvCreateMat(src-&gt;rows, src-&gt;cols, CV_32FC1);  </div><div class="line">	convkernel = GaussianKernel1D(sigma, dim);  </div><div class="line"></div><div class="line">	Convolve1DWidth(convkernel, dim, src, tempMat);  </div><div class="line">	Convolve1DHeight(convkernel, dim, tempMat, dst);  </div><div class="line">	cvReleaseMat(&tempMat);  </div><div class="line">	<span class="keyword">return</span> dim;  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="五个步骤"><strong>五个步骤</strong></h3>
<p>ok，接下来，进入重点部分，咱们依据上文介绍的sift算法的几个步骤，来一一实现这些函数。</p>
<p>为了版述清晰，再贴一下，主函数，顺便再加强下对sift 算法的五个步骤的认识：</p>
<p>1、 SIFT算法第一步：图像预处理</p>
<p>CvMat *ScaleInitImage(CvMat * im) ;                  //金字塔初始化</p>
<p>2、 SIFT算法第二步：建立高斯金字塔函数</p>
<p>ImageOctaves* BuildGaussianOctaves(CvMat * image) ;  //建立高斯金字塔</p>
<p>3、 SIFT算法第三步：特征点位置检测，最后确定特征点的位置</p>
<p>int DetectKeypoint(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>4、 SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向</p>
<p>void ComputeGrad_DirecandMag(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>5、 SIFT算法第五步：抽取各个特征点处的特征描述字</p>
<p>void ExtractFeatureDescriptors(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>ok，接下来一一具体实现这几个函数：</p>
<h4 id="SIFT算法第一步"><strong>SIFT算法第一步</strong></h4>
<p>SIFT算法第一步：扩大图像，预滤波剔除噪声，得到金字塔的最底层-第一阶的第一层：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">CvMat *ScaleInitImage(CvMat * im)   </div><div class="line">{  </div><div class="line">	<span class="keyword">double</span> sigma,preblur_sigma;  </div><div class="line">	CvMat *imMat;  </div><div class="line">	CvMat * dst;  </div><div class="line">	CvMat *tempMat;  </div><div class="line">	<span class="comment">//首先对图像进行平滑滤波，抑制噪声  </span></div><div class="line">	imMat = cvCreateMat(im-&gt;rows, im-&gt;cols, CV_32FC1);  </div><div class="line">	BlurImage(im, imMat, INITSIGMA);  </div><div class="line">	<span class="comment">//针对两种情况分别进行处理：初始化放大原始图像或者在原图像基础上进行后续操作  </span></div><div class="line">	<span class="comment">//建立金字塔的最底层  </span></div><div class="line">	<span class="keyword">if</span> (DOUBLE_BASE_IMAGE_SIZE)   </div><div class="line">	{  </div><div class="line">		tempMat = doubleSizeImage2(imMat);<span class="comment">//对扩大两倍的图像进行二次采样，采样率为0.5，采用线性插值  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TEMPMAT(ROW,COL) ((float *)(tempMat-&gt;data.fl + tempMat-&gt;step/sizeof(float) * (ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">		dst = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);  </div><div class="line">		preblur_sigma = <span class="number">1.0</span>;<span class="comment">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span></div><div class="line">		BlurImage(tempMat, dst, preblur_sigma);   </div><div class="line"></div><div class="line">		<span class="comment">// The initial blurring for the first image of the first octave of the pyramid.  </span></div><div class="line">		sigma = <span class="built_in">sqrt</span>( (<span class="number">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  </div><div class="line">		<span class="comment">//  sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span></div><div class="line">		<span class="comment">//printf("Init Sigma: %f/n", sigma);  </span></div><div class="line">		BlurImage(dst, tempMat, sigma);       <span class="comment">//得到金字塔的最底层-放大2倍的图像  </span></div><div class="line">		cvReleaseMat( &dst );   </div><div class="line">		<span class="keyword">return</span> tempMat;  </div><div class="line">	}   </div><div class="line">	<span class="keyword">else</span>   </div><div class="line">	{  </div><div class="line">		dst = cvCreateMat(im-&gt;rows, im-&gt;cols, CV_32FC1);  </div><div class="line">		<span class="comment">//sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA);  </span></div><div class="line">		preblur_sigma = <span class="number">1.0</span>;<span class="comment">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span></div><div class="line">		sigma = <span class="built_in">sqrt</span>( (<span class="number">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  </div><div class="line">		<span class="comment">//printf("Init Sigma: %f/n", sigma);  </span></div><div class="line">		BlurImage(imMat, dst, sigma);        <span class="comment">//得到金字塔的最底层：原始图像大小  </span></div><div class="line">		<span class="keyword">return</span> dst;  </div><div class="line">	}   </div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="SIFT算法第二步"><strong>SIFT算法第二步</strong></h4>
<p>SIFT第二步，建立Gaussian金字塔，给定金字塔第一阶第一层图像后，计算高斯金字塔其他尺度图像，<br>每一阶的数目由变量SCALESPEROCTAVE决定，给定一个基本图像，计算它的高斯金字塔图像，返回外部向量是阶梯指针，内部向量是每一个阶梯内部的不同尺度图像。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SIFT算法第二步  </span></div><div class="line">ImageOctaves* BuildGaussianOctaves(CvMat * image)   </div><div class="line">{  </div><div class="line">	ImageOctaves *octaves;  </div><div class="line">	CvMat *tempMat;  </div><div class="line">	CvMat *dst;  </div><div class="line">	CvMat *temp;  </div><div class="line"></div><div class="line">	<span class="keyword">int</span> i,j;  </div><div class="line">	<span class="keyword">double</span> k = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1.0</span>/((<span class="keyword">float</span>)SCALESPEROCTAVE));  <span class="comment">//方差倍数  </span></div><div class="line">	<span class="keyword">float</span> preblur_sigma, initial_sigma , sigma1,sigma2,sigma,absolute_sigma,sigma_f;  </div><div class="line">	<span class="comment">//计算金字塔的阶梯数目  </span></div><div class="line">	<span class="keyword">int</span> dim = min(image-&gt;rows, image-&gt;cols);  </div><div class="line">	<span class="keyword">int</span> numoctaves = (<span class="keyword">int</span>) (<span class="built_in">log</span>((<span class="keyword">double</span>) dim) / <span class="built_in">log</span>(<span class="number">2.0</span>)) - <span class="number">2</span>;    <span class="comment">//金字塔阶数  </span></div><div class="line">	<span class="comment">//限定金字塔的阶梯数  </span></div><div class="line">	numoctaves = min(numoctaves, MAXOCTAVES);  </div><div class="line">	<span class="comment">//为高斯金塔和DOG金字塔分配内存  </span></div><div class="line">	octaves=(ImageOctaves*) <span class="built_in">malloc</span>( numoctaves * <span class="keyword">sizeof</span>(ImageOctaves) );  </div><div class="line">	DOGoctaves=(ImageOctaves*) <span class="built_in">malloc</span>( numoctaves * <span class="keyword">sizeof</span>(ImageOctaves) );  </div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"BuildGaussianOctaves(): Base image dimension is %dx%d/n"</span>, (<span class="keyword">int</span>)(<span class="number">0.5</span>*(image-&gt;cols)), (<span class="keyword">int</span>)(<span class="number">0.5</span>*(image-&gt;rows)) );  </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"BuildGaussianOctaves(): Building %d octaves/n"</span>, numoctaves);  </div><div class="line"></div><div class="line">	<span class="comment">// start with initial source image  </span></div><div class="line">	tempMat=cvCloneMat( image );  </div><div class="line">	<span class="comment">// preblur_sigma = 1.0;//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span></div><div class="line">	initial_sigma = <span class="built_in">sqrt</span>(<span class="number">2</span>);<span class="comment">//sqrt( (4*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  </span></div><div class="line">	<span class="comment">//   initial_sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span></div><div class="line"></div><div class="line">	<span class="comment">//在每一阶金字塔图像中建立不同的尺度图像  </span></div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; numoctaves; i++)   </div><div class="line">	{     </div><div class="line">		<span class="comment">//首先建立金字塔每一阶梯的最底层，其中0阶梯的最底层已经建立好  </span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Building octave %d of dimesion (%d, %d)/n"</span>, i, tempMat-&gt;cols,tempMat-&gt;rows);  </div><div class="line">		<span class="comment">//为各个阶梯分配内存  </span></div><div class="line">		octaves[i].Octave= (ImageLevels*) <span class="built_in">malloc</span>( (SCALESPEROCTAVE + <span class="number">3</span>) * <span class="keyword">sizeof</span>(ImageLevels) );  </div><div class="line">		DOGoctaves[i].Octave= (ImageLevels*) <span class="built_in">malloc</span>( (SCALESPEROCTAVE + <span class="number">2</span>) * <span class="keyword">sizeof</span>(ImageLevels) );  </div><div class="line">		<span class="comment">//存储各个阶梯的最底层  </span></div><div class="line">		(octaves[i].Octave)[<span class="number">0</span>].Level=tempMat;  </div><div class="line"></div><div class="line">		octaves[i].col=tempMat-&gt;cols;  </div><div class="line">		octaves[i].row=tempMat-&gt;rows;  </div><div class="line">		DOGoctaves[i].col=tempMat-&gt;cols;  </div><div class="line">		DOGoctaves[i].row=tempMat-&gt;rows;  </div><div class="line">		<span class="keyword">if</span> (DOUBLE_BASE_IMAGE_SIZE)  </div><div class="line">			octaves[i].subsample=<span class="built_in">pow</span>(<span class="number">2</span>,i)*<span class="number">0.5</span>;  </div><div class="line">		<span class="keyword">else</span>  </div><div class="line">			octaves[i].subsample=<span class="built_in">pow</span>(<span class="number">2</span>,i);  </div><div class="line"></div><div class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)       </div><div class="line">		{  </div><div class="line">			(octaves[<span class="number">0</span>].Octave)[<span class="number">0</span>].levelsigma = initial_sigma;  </div><div class="line">			(octaves[<span class="number">0</span>].Octave)[<span class="number">0</span>].absolute_sigma = initial_sigma;  </div><div class="line">			<span class="built_in">printf</span>(<span class="string">"0 scale and blur sigma : %f /n"</span>, (octaves[<span class="number">0</span>].subsample) * ((octaves[<span class="number">0</span>].Octave)[<span class="number">0</span>].absolute_sigma));  </div><div class="line">		}  </div><div class="line">		<span class="keyword">else</span>  </div><div class="line">		{  </div><div class="line">			(octaves[i].Octave)[<span class="number">0</span>].levelsigma = (octaves[i-<span class="number">1</span>].Octave)[SCALESPEROCTAVE].levelsigma;  </div><div class="line">			(octaves[i].Octave)[<span class="number">0</span>].absolute_sigma = (octaves[i-<span class="number">1</span>].Octave)[SCALESPEROCTAVE].absolute_sigma;  </div><div class="line">			<span class="built_in">printf</span>( <span class="string">"0 scale and blur sigma : %f /n"</span>, ((octaves[i].Octave)[<span class="number">0</span>].absolute_sigma) );  </div><div class="line">		}  </div><div class="line">		sigma = initial_sigma;  </div><div class="line">		<span class="comment">//建立本阶梯其他层的图像  </span></div><div class="line">		<span class="keyword">for</span> ( j =  <span class="number">1</span>; j &lt; SCALESPEROCTAVE + <span class="number">3</span>; j++)   </div><div class="line">		{  </div><div class="line">			dst = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);<span class="comment">//用于存储高斯层  </span></div><div class="line">			temp = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);<span class="comment">//用于存储DOG层  </span></div><div class="line">			<span class="comment">// 2 passes of 1D on original  </span></div><div class="line">			<span class="comment">//   if(i!=0)  </span></div><div class="line">			<span class="comment">//   {  </span></div><div class="line">			<span class="comment">//       sigma1 = pow(k, j - 1) * ((octaves[i-1].Octave)[j-1].levelsigma);  </span></div><div class="line">			<span class="comment">//          sigma2 = pow(k, j) * ((octaves[i].Octave)[j-1].levelsigma);  </span></div><div class="line">			<span class="comment">//       sigma = sqrt(sigma2*sigma2 - sigma1*sigma1);  </span></div><div class="line">			sigma_f= <span class="built_in">sqrt</span>(k*k-<span class="number">1</span>)*sigma;  </div><div class="line">			<span class="comment">//   }  </span></div><div class="line">			<span class="comment">//   else  </span></div><div class="line">			<span class="comment">//   {  </span></div><div class="line">			<span class="comment">//       sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4)*pow(k,j);  </span></div><div class="line">			<span class="comment">//   }    </span></div><div class="line">			sigma = k*sigma;  </div><div class="line">			absolute_sigma = sigma * (octaves[i].subsample);  </div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d scale and Blur sigma: %f  /n"</span>, j, absolute_sigma);  </div><div class="line"></div><div class="line">			(octaves[i].Octave)[j].levelsigma = sigma;  </div><div class="line">			(octaves[i].Octave)[j].absolute_sigma = absolute_sigma;  </div><div class="line">			<span class="comment">//产生高斯层  </span></div><div class="line">			<span class="keyword">int</span> length=BlurImage((octaves[i].Octave)[j-<span class="number">1</span>].Level, dst, sigma_f);<span class="comment">//相应尺度  </span></div><div class="line">			(octaves[i].Octave)[j].levelsigmalength = length;  </div><div class="line">			(octaves[i].Octave)[j].Level=dst;  </div><div class="line">			<span class="comment">//产生DOG层  </span></div><div class="line">			cvSub( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-<span class="number">1</span>]).Level, temp, <span class="number">0</span> );  </div><div class="line">			<span class="comment">//         cvAbsDiff( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-1]).Level, temp );  </span></div><div class="line">			((DOGoctaves[i].Octave)[j-<span class="number">1</span>]).Level=temp;  </div><div class="line">		}  </div><div class="line">		<span class="comment">// halve the image size for next iteration  </span></div><div class="line">		tempMat  = halfSizeImage( ( (octaves[i].Octave)[SCALESPEROCTAVE].Level ) );  </div><div class="line">	}  </div><div class="line">	<span class="keyword">return</span> octaves;  </div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="SIFT算法第三步"><strong>SIFT算法第三步</strong></h4>
<p>SIFT算法第三步，特征点位置检测，最后确定特征点的位置检测DOG金字塔中的局部最大值，找到之后，还要经过两个检验才能确认为特征点：一是它必须有明显的差异，二是他不应该是边缘点，（也就是说，在极值点处的主曲率比应该小于某一个阈值）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SIFT算法第三步，特征点位置检测，  </span></div><div class="line"><span class="keyword">int</span> DetectKeypoint(<span class="keyword">int</span> numoctaves, ImageOctaves *GaussianPyr)  </div><div class="line">{  </div><div class="line">	<span class="comment">//计算用于DOG极值点检测的主曲率比的阈值  </span></div><div class="line">	<span class="keyword">double</span> curvature_threshold;  </div><div class="line">	curvature_threshold= ((CURVATURE_THRESHOLD + <span class="number">1</span>)*(CURVATURE_THRESHOLD + <span class="number">1</span>))/CURVATURE_THRESHOLD;  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	<span class="keyword">int</span>   keypoint_count = <span class="number">0</span>;     </div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numoctaves; i++)    </div><div class="line">	{          </div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;SCALESPEROCTAVE+<span class="number">1</span>;j++)<span class="comment">//取中间的scaleperoctave个层  </span></div><div class="line">		{    </div><div class="line">			<span class="comment">//在图像的有效区域内寻找具有显著性特征的局部最大值  </span></div><div class="line">			<span class="comment">//float sigma=(GaussianPyr[i].Octave)[j].levelsigma;  </span></div><div class="line">			<span class="comment">//int dim = (int) (max(3.0f, 2.0*GAUSSKERN *sigma + 1.0f)*0.5);  </span></div><div class="line">			<span class="keyword">int</span> dim = (<span class="keyword">int</span>)(<span class="number">0.5</span>*((GaussianPyr[i].Octave)[j].levelsigmalength)+<span class="number">0.5</span>);  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m=dim;m&lt;((DOGoctaves[i].row)-dim);m++)   </div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> n=dim;n&lt;((DOGoctaves[i].col)-dim);n++)  </div><div class="line">				{       </div><div class="line">					<span class="keyword">if</span> ( <span class="built_in">fabs</span>(ImLevels(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  </div><div class="line">					{  </div><div class="line"></div><div class="line">						<span class="keyword">if</span> ( ImLevels(i,j,m,n)!=<span class="number">0.0</span> )  <span class="comment">//1、首先是非零  </span></div><div class="line">						{  </div><div class="line">							<span class="keyword">float</span> inf_val=ImLevels(i,j,m,n);  </div><div class="line">							<span class="keyword">if</span>(( (inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m  ,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n+<span class="number">1</span>))&&    <span class="comment">//底层的小尺度9  </span></div><div class="line"></div><div class="line">								(inf_val &lt;= ImLevels(i,j,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j,m+<span class="number">1</span>,n+<span class="number">1</span>))&&     <span class="comment">//当前层8  </span></div><div class="line"></div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m  ,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &lt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n+<span class="number">1</span>))     <span class="comment">//下一层大尺度9          </span></div><div class="line">								) ||   </div><div class="line">								( (inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m  ,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j-<span class="number">1</span>,m+<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line"></div><div class="line">								(inf_val &gt;= ImLevels(i,j,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j,m+<span class="number">1</span>,n+<span class="number">1</span>))&&   </div><div class="line"></div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m  ,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n-<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m  ,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n  ))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m-<span class="number">1</span>,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m  ,n+<span class="number">1</span>))&&  </div><div class="line">								(inf_val &gt;= ImLevels(i,j+<span class="number">1</span>,m+<span class="number">1</span>,n+<span class="number">1</span>))   </div><div class="line">								) )      <span class="comment">//2、满足26个中极值点  </span></div><div class="line">							{     </div><div class="line">								<span class="comment">//此处可存储  </span></div><div class="line">								<span class="comment">//然后必须具有明显的显著性，即必须大于CONTRAST_THRESHOLD=0.02  </span></div><div class="line">								<span class="keyword">if</span> ( <span class="built_in">fabs</span>(ImLevels(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  </div><div class="line">								{  </div><div class="line">									<span class="comment">//最后显著处的特征点必须具有足够的曲率比，CURVATURE_THRESHOLD=10.0，首先计算Hessian矩阵  </span></div><div class="line">									<span class="comment">// Compute the entries of the Hessian matrix at the extrema location.  </span></div><div class="line">									<span class="comment">/* </span></div><div class="line">									1   0   -1 </div><div class="line">									0   0   0 </div><div class="line">									-1   0   1         *0.25 </div><div class="line">									*/  </div><div class="line">									<span class="comment">// Compute the trace and the determinant of the Hessian.  </span></div><div class="line">									<span class="comment">//Tr_H = Dxx + Dyy;  </span></div><div class="line">									<span class="comment">//Det_H = Dxx*Dyy - Dxy^2;  </span></div><div class="line">									<span class="keyword">float</span> Dxx,Dyy,Dxy,Tr_H,Det_H,curvature_ratio;  </div><div class="line">									Dxx = ImLevels(i,j,m,n-<span class="number">1</span>) + ImLevels(i,j,m,n+<span class="number">1</span>)-<span class="number">2.0</span>*ImLevels(i,j,m,n);  </div><div class="line">									Dyy = ImLevels(i,j,m-<span class="number">1</span>,n) + ImLevels(i,j,m+<span class="number">1</span>,n)-<span class="number">2.0</span>*ImLevels(i,j,m,n);  </div><div class="line">									Dxy = ImLevels(i,j,m-<span class="number">1</span>,n-<span class="number">1</span>) + ImLevels(i,j,m+<span class="number">1</span>,n+<span class="number">1</span>) - ImLevels(i,j,m+<span class="number">1</span>,n-<span class="number">1</span>) - ImLevels(i,j,m-<span class="number">1</span>,n+<span class="number">1</span>);  </div><div class="line">									Tr_H = Dxx + Dyy;  </div><div class="line">									Det_H = Dxx*Dyy - Dxy*Dxy;  </div><div class="line">									<span class="comment">// Compute the ratio of the principal curvatures.  </span></div><div class="line">									curvature_ratio = (<span class="number">1.0</span>*Tr_H*Tr_H)/Det_H;  </div><div class="line">									<span class="keyword">if</span> ( (Det_H&gt;=<span class="number">0.0</span>) && (curvature_ratio &lt;= curvature_threshold) )  <span class="comment">//最后得到最具有显著性特征的特征点  </span></div><div class="line">									{  </div><div class="line">										<span class="comment">//将其存储起来，以计算后面的特征描述字  </span></div><div class="line">										keypoint_count++;  </div><div class="line">										Keypoint k;  </div><div class="line">										<span class="comment">/* Allocate memory for the keypoint. */</span>  </div><div class="line">										k = (Keypoint) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> KeypointSt));  </div><div class="line">										k-&gt;next = keypoints;  </div><div class="line">										keypoints = k;  </div><div class="line">										k-&gt;row = m*(GaussianPyr[i].subsample);  </div><div class="line">										k-&gt;col =n*(GaussianPyr[i].subsample);  </div><div class="line">										k-&gt;sy = m;    <span class="comment">//行  </span></div><div class="line">										k-&gt;sx = n;    <span class="comment">//列  </span></div><div class="line">										k-&gt;octave=i;  </div><div class="line">										k-&gt;level=j;  </div><div class="line">										k-&gt;scale = (GaussianPyr[i].Octave)[j].absolute_sigma;        </div><div class="line">									}<span class="comment">//if &gt;curvature_thresh  </span></div><div class="line">								}<span class="comment">//if &gt;contrast  </span></div><div class="line">							}<span class="comment">//if inf value  </span></div><div class="line">						}<span class="comment">//if non zero  </span></div><div class="line">					}<span class="comment">//if &gt;contrast  </span></div><div class="line">				}  <span class="comment">//for concrete image level col  </span></div><div class="line">		}<span class="comment">//for levels  </span></div><div class="line">	}<span class="comment">//for octaves  </span></div><div class="line">	<span class="keyword">return</span> keypoint_count;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//在图像中，显示SIFT特征点的位置  </span></div><div class="line"><span class="keyword">void</span> DisplayKeypointLocation(IplImage* image, ImageOctaves *GaussianPyr)  </div><div class="line">{  </div><div class="line"></div><div class="line">	Keypoint p = keypoints; <span class="comment">// p指向第一个结点  </span></div><div class="line">	<span class="keyword">while</span>(p) <span class="comment">// 没到表尾  </span></div><div class="line">	{     </div><div class="line">		cvLine( image, cvPoint((<span class="keyword">int</span>)((p-&gt;col)-<span class="number">3</span>),(<span class="keyword">int</span>)(p-&gt;row)),   </div><div class="line">			cvPoint((<span class="keyword">int</span>)((p-&gt;col)+<span class="number">3</span>),(<span class="keyword">int</span>)(p-&gt;row)), CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),  </div><div class="line">			<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );  </div><div class="line">		cvLine( image, cvPoint((<span class="keyword">int</span>)(p-&gt;col),(<span class="keyword">int</span>)((p-&gt;row)-<span class="number">3</span>)),   </div><div class="line">			cvPoint((<span class="keyword">int</span>)(p-&gt;col),(<span class="keyword">int</span>)((p-&gt;row)+<span class="number">3</span>)), CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),  </div><div class="line">			<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );  </div><div class="line">		<span class="comment">//  cvCircle(image,cvPoint((uchar)(p-&gt;col),(uchar)(p-&gt;row)),  </span></div><div class="line">		<span class="comment">//   (int)((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma),  </span></div><div class="line">		<span class="comment">//   CV_RGB(255,0,0),1,8,0);  </span></div><div class="line">		p=p-&gt;next;  </div><div class="line">	}   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// Compute the gradient direction and magnitude of the gaussian pyramid images  </span></div><div class="line"><span class="keyword">void</span> ComputeGrad_DirecandMag(<span class="keyword">int</span> numoctaves, ImageOctaves *GaussianPyr)  </div><div class="line">{  </div><div class="line">	<span class="comment">// ImageOctaves *mag_thresh ;  </span></div><div class="line">	mag_pyr=(ImageOctaves*) <span class="built_in">malloc</span>( numoctaves * <span class="keyword">sizeof</span>(ImageOctaves) );  </div><div class="line">	grad_pyr=(ImageOctaves*) <span class="built_in">malloc</span>( numoctaves * <span class="keyword">sizeof</span>(ImageOctaves) );  </div><div class="line">	<span class="comment">// float sigma=( (GaussianPyr[0].Octave)[SCALESPEROCTAVE+2].absolute_sigma ) / GaussianPyr[0].subsample;  </span></div><div class="line">	<span class="comment">// int dim = (int) (max(3.0f, 2 * GAUSSKERN *sigma + 1.0f)*0.5+0.5);  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numoctaves; i++)    </div><div class="line">	{          </div><div class="line">		mag_pyr[i].Octave= (ImageLevels*) <span class="built_in">malloc</span>( (SCALESPEROCTAVE) * <span class="keyword">sizeof</span>(ImageLevels) );  </div><div class="line">		grad_pyr[i].Octave= (ImageLevels*) <span class="built_in">malloc</span>( (SCALESPEROCTAVE) * <span class="keyword">sizeof</span>(ImageLevels) );  </div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;SCALESPEROCTAVE+<span class="number">1</span>;j++)<span class="comment">//取中间的scaleperoctave个层  </span></div><div class="line">		{    </div><div class="line">			CvMat *Mag = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  </div><div class="line">			CvMat *Ori = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  </div><div class="line">			CvMat *tempMat1 = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  </div><div class="line">			CvMat *tempMat2 = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  </div><div class="line">			cvZero(Mag);  </div><div class="line">			cvZero(Ori);  </div><div class="line">			cvZero(tempMat1);  </div><div class="line">			cvZero(tempMat2);   </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAG(ROW,COL) ((float *)(Mag-&gt;data.fl + Mag-&gt;step/sizeof(float) *(ROW)))[(COL)]     </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ORI(ROW,COL) ((float *)(Ori-&gt;data.fl + Ori-&gt;step/sizeof(float) *(ROW)))[(COL)]    </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TEMPMAT1(ROW,COL) ((float *)(tempMat1-&gt;data.fl + tempMat1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> TEMPMAT2(ROW,COL) ((float *)(tempMat2-&gt;data.fl + tempMat2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;(GaussianPyr[i].row-<span class="number">1</span>);m++)   </div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;(GaussianPyr[i].col-<span class="number">1</span>);n++)  </div><div class="line">				{  </div><div class="line">					<span class="comment">//计算幅值  </span></div><div class="line">					TEMPMAT1(m,n) = <span class="number">0.5</span>*( ImLevels(i,j,m,n+<span class="number">1</span>)-ImLevels(i,j,m,n-<span class="number">1</span>) );  <span class="comment">//dx  </span></div><div class="line">					TEMPMAT2(m,n) = <span class="number">0.5</span>*( ImLevels(i,j,m+<span class="number">1</span>,n)-ImLevels(i,j,m-<span class="number">1</span>,n) );  <span class="comment">//dy  </span></div><div class="line">					MAG(m,n) = <span class="built_in">sqrt</span>(TEMPMAT1(m,n)*TEMPMAT1(m,n)+TEMPMAT2(m,n)*TEMPMAT2(m,n));  <span class="comment">//mag  </span></div><div class="line">					<span class="comment">//计算方向  </span></div><div class="line">					ORI(m,n) =<span class="built_in">atan</span>( TEMPMAT2(m,n)/TEMPMAT1(m,n) );  </div><div class="line">					<span class="keyword">if</span> (ORI(m,n)==CV_PI)  </div><div class="line">						ORI(m,n)=-CV_PI;  </div><div class="line">				}  </div><div class="line">				((mag_pyr[i].Octave)[j-<span class="number">1</span>]).Level=Mag;  </div><div class="line">				((grad_pyr[i].Octave)[j-<span class="number">1</span>]).Level=Ori;  </div><div class="line">				cvReleaseMat(&tempMat1);  </div><div class="line">				cvReleaseMat(&tempMat2);  </div><div class="line">		}<span class="comment">//for levels  </span></div><div class="line">	}<span class="comment">//for octaves  </span></div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="SIFT算法第四步"><strong>SIFT算法第四步</strong></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SIFT算法第四步：计算各个特征点的主方向，确定主方向  </span></div><div class="line"><span class="keyword">void</span> AssignTheMainOrientation(<span class="keyword">int</span> numoctaves, ImageOctaves *GaussianPyr,ImageOctaves *mag_pyr,ImageOctaves *grad_pyr)  </div><div class="line">{  </div><div class="line">	<span class="comment">// Set up the histogram bin centers for a 36 bin histogram.  </span></div><div class="line">	<span class="keyword">int</span> num_bins = <span class="number">36</span>;  </div><div class="line">	<span class="keyword">float</span> hist_step = <span class="number">2.0</span>*PI/num_bins;  </div><div class="line">	<span class="keyword">float</span> hist_orient[<span class="number">36</span>];  </div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">36</span>;i++)  </div><div class="line">		hist_orient[i]=-PI+i*hist_step;  </div><div class="line">	<span class="keyword">float</span> sigma1=( ((GaussianPyr[<span class="number">0</span>].Octave)[SCALESPEROCTAVE].absolute_sigma) ) / (GaussianPyr[<span class="number">0</span>].subsample);<span class="comment">//SCALESPEROCTAVE+2  </span></div><div class="line">	<span class="keyword">int</span> zero_pad = (<span class="keyword">int</span>) (max(<span class="number">3.0f</span>, <span class="number">2</span> * GAUSSKERN *sigma1 + <span class="number">1.0f</span>)*<span class="number">0.5</span>+<span class="number">0.5</span>);  </div><div class="line">	<span class="comment">//Assign orientations to the keypoints.  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ImLevels(OCTAVES,LEVELS,ROW,COL) ((float *)((GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;data.fl + (GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> keypoint_count = <span class="number">0</span>;  </div><div class="line">	Keypoint p = keypoints; <span class="comment">// p指向第一个结点  </span></div><div class="line"></div><div class="line">	<span class="keyword">while</span>(p) <span class="comment">// 没到表尾  </span></div><div class="line">	{  </div><div class="line">		<span class="keyword">int</span> i=p-&gt;octave;  </div><div class="line">		<span class="keyword">int</span> j=p-&gt;level;  </div><div class="line">		<span class="keyword">int</span> m=p-&gt;sy;   <span class="comment">//行  </span></div><div class="line">		<span class="keyword">int</span> n=p-&gt;sx;   <span class="comment">//列  </span></div><div class="line">		<span class="keyword">if</span> ((m&gt;=zero_pad)&&(m&lt;GaussianPyr[i].row-zero_pad)&&  </div><div class="line">			(n&gt;=zero_pad)&&(n&lt;GaussianPyr[i].col-zero_pad) )  </div><div class="line">		{  </div><div class="line">			<span class="keyword">float</span> sigma=( ((GaussianPyr[i].Octave)[j].absolute_sigma) ) / (GaussianPyr[i].subsample);  </div><div class="line">			<span class="comment">//产生二维高斯模板  </span></div><div class="line">			CvMat* mat = GaussianKernel2D( sigma );           </div><div class="line">			<span class="keyword">int</span> dim=(<span class="keyword">int</span>)(<span class="number">0.5</span> * (mat-&gt;rows));  </div><div class="line">			<span class="comment">//分配用于存储Patch幅值和方向的空间  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAT(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">			<span class="comment">//声明方向直方图变量  </span></div><div class="line">			<span class="keyword">double</span>* orienthist = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(<span class="number">36</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));  </div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">int</span> sw = <span class="number">0</span> ; sw &lt; <span class="number">36</span> ; ++sw)   </div><div class="line">			{  </div><div class="line">				orienthist[sw]=<span class="number">0.0</span>;    </div><div class="line">			}  </div><div class="line">			<span class="comment">//在特征点的周围统计梯度方向  </span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x=m-dim,mm=<span class="number">0</span>;x&lt;=(m+dim);x++,mm++)   </div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y=n-dim,nn=<span class="number">0</span>;y&lt;=(n+dim);y++,nn++)  </div><div class="line">				{       </div><div class="line">					<span class="comment">//计算特征点处的幅值  </span></div><div class="line">					<span class="keyword">double</span> dx = <span class="number">0.5</span>*(ImLevels(i,j,x,y+<span class="number">1</span>)-ImLevels(i,j,x,y-<span class="number">1</span>));  <span class="comment">//dx  </span></div><div class="line">					<span class="keyword">double</span> dy = <span class="number">0.5</span>*(ImLevels(i,j,x+<span class="number">1</span>,y)-ImLevels(i,j,x-<span class="number">1</span>,y));  <span class="comment">//dy  </span></div><div class="line">					<span class="keyword">double</span> mag = <span class="built_in">sqrt</span>(dx*dx+dy*dy);  <span class="comment">//mag  </span></div><div class="line">					<span class="comment">//计算方向  </span></div><div class="line">					<span class="keyword">double</span> Ori =<span class="built_in">atan</span>( <span class="number">1.0</span>*dy/dx );  </div><div class="line">					<span class="keyword">int</span> binIdx = FindClosestRotationBin(<span class="number">36</span>, Ori);                   <span class="comment">//得到离现有方向最近的直方块  </span></div><div class="line">					orienthist[binIdx] = orienthist[binIdx] + <span class="number">1.0</span>* mag * MAT(mm,nn);<span class="comment">//利用高斯加权累加进直方图相应的块  </span></div><div class="line">				}  </div><div class="line">				<span class="comment">// Find peaks in the orientation histogram using nonmax suppression.  </span></div><div class="line">				AverageWeakBins (orienthist, <span class="number">36</span>);  </div><div class="line">				<span class="comment">// find the maximum peak in gradient orientation  </span></div><div class="line">				<span class="keyword">double</span> maxGrad = <span class="number">0.0</span>;  </div><div class="line">				<span class="keyword">int</span> maxBin = <span class="number">0</span>;  </div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span> ; b &lt; <span class="number">36</span> ; ++b)   </div><div class="line">				{  </div><div class="line">					<span class="keyword">if</span> (orienthist[b] &gt; maxGrad)   </div><div class="line">					{  </div><div class="line">						maxGrad = orienthist[b];  </div><div class="line">						maxBin = b;  </div><div class="line">					}  </div><div class="line">				}  </div><div class="line">				<span class="comment">// First determine the real interpolated peak high at the maximum bin  </span></div><div class="line">				<span class="comment">// position, which is guaranteed to be an absolute peak.  </span></div><div class="line">				<span class="keyword">double</span> maxPeakValue=<span class="number">0.0</span>;  </div><div class="line">				<span class="keyword">double</span> maxDegreeCorrection=<span class="number">0.0</span>;  </div><div class="line">				<span class="keyword">if</span> ( (InterpolateOrientation ( orienthist[maxBin == <span class="number">0</span> ? (<span class="number">36</span> - <span class="number">1</span>) : (maxBin - <span class="number">1</span>)],  </div><div class="line">					orienthist[maxBin], orienthist[(maxBin + <span class="number">1</span>) % <span class="number">36</span>],  </div><div class="line">					&maxDegreeCorrection, &maxPeakValue)) == <span class="keyword">false</span>)  </div><div class="line">					<span class="built_in">printf</span>(<span class="string">"BUG: Parabola fitting broken"</span>);  </div><div class="line"></div><div class="line">				<span class="comment">// Now that we know the maximum peak value, we can find other keypoint  </span></div><div class="line">				<span class="comment">// orientations, which have to fulfill two criterias:  </span></div><div class="line">				<span class="comment">//  </span></div><div class="line">				<span class="comment">//  1. They must be a local peak themselves. Else we might add a very  </span></div><div class="line">				<span class="comment">//     similar keypoint orientation twice (imagine for example the  </span></div><div class="line">				<span class="comment">//     values: 0.4 1.0 0.8, if 1.0 is maximum peak, 0.8 is still added  </span></div><div class="line">				<span class="comment">//     with the default threshhold, but the maximum peak orientation  </span></div><div class="line">				<span class="comment">//     was already added).  </span></div><div class="line">				<span class="comment">//  2. They must have at least peakRelThresh times the maximum peak  </span></div><div class="line">				<span class="comment">//     value.  </span></div><div class="line">				<span class="keyword">bool</span> binIsKeypoint[<span class="number">36</span>];  </div><div class="line">				<span class="keyword">for</span> ( b = <span class="number">0</span> ; b &lt; <span class="number">36</span> ; ++b)   </div><div class="line">				{  </div><div class="line">					binIsKeypoint[b] = <span class="keyword">false</span>;  </div><div class="line">					<span class="comment">// The maximum peak of course is  </span></div><div class="line">					<span class="keyword">if</span> (b == maxBin)   </div><div class="line">					{  </div><div class="line">						binIsKeypoint[b] = <span class="keyword">true</span>;  </div><div class="line">						<span class="keyword">continue</span>;  </div><div class="line">					}  </div><div class="line">					<span class="comment">// Local peaks are, too, in case they fulfill the threshhold  </span></div><div class="line">					<span class="keyword">if</span> (orienthist[b] &lt; (peakRelThresh * maxPeakValue))  </div><div class="line">						<span class="keyword">continue</span>;  </div><div class="line">					<span class="keyword">int</span> leftI = (b == <span class="number">0</span>) ? (<span class="number">36</span> - <span class="number">1</span>) : (b - <span class="number">1</span>);  </div><div class="line">					<span class="keyword">int</span> rightI = (b + <span class="number">1</span>) % <span class="number">36</span>;  </div><div class="line">					<span class="keyword">if</span> (orienthist[b] &lt;= orienthist[leftI] || orienthist[b] &lt;= orienthist[rightI])  </div><div class="line">						<span class="keyword">continue</span>; <span class="comment">// no local peak  </span></div><div class="line">					binIsKeypoint[b] = <span class="keyword">true</span>;  </div><div class="line">				}  </div><div class="line">				<span class="comment">// find other possible locations  </span></div><div class="line">				<span class="keyword">double</span> oneBinRad = (<span class="number">2.0</span> * PI) / <span class="number">36</span>;  </div><div class="line">				<span class="keyword">for</span> ( b = <span class="number">0</span> ; b &lt; <span class="number">36</span> ; ++b)   </div><div class="line">				{  </div><div class="line">					<span class="keyword">if</span> (binIsKeypoint[b] == <span class="keyword">false</span>)  </div><div class="line">						<span class="keyword">continue</span>;  </div><div class="line">					<span class="keyword">int</span> bLeft = (b == <span class="number">0</span>) ? (<span class="number">36</span> - <span class="number">1</span>) : (b - <span class="number">1</span>);  </div><div class="line">					<span class="keyword">int</span> bRight = (b + <span class="number">1</span>) % <span class="number">36</span>;  </div><div class="line">					<span class="comment">// Get an interpolated peak direction and value guess.  </span></div><div class="line">					<span class="keyword">double</span> peakValue;  </div><div class="line">					<span class="keyword">double</span> degreeCorrection;  </div><div class="line"></div><div class="line">					<span class="keyword">double</span> maxPeakValue, maxDegreeCorrection;                </div><div class="line">					<span class="keyword">if</span> (InterpolateOrientation ( orienthist[maxBin == <span class="number">0</span> ? (<span class="number">36</span> - <span class="number">1</span>) : (maxBin - <span class="number">1</span>)],  </div><div class="line">						orienthist[maxBin], orienthist[(maxBin + <span class="number">1</span>) % <span class="number">36</span>],  </div><div class="line">						°reeCorrection, &peakValue) == <span class="keyword">false</span>)  </div><div class="line">					{  </div><div class="line">						<span class="built_in">printf</span>(<span class="string">"BUG: Parabola fitting broken"</span>);  </div><div class="line">					}  </div><div class="line"></div><div class="line">					<span class="keyword">double</span> degree = (b + degreeCorrection) * oneBinRad - PI;  </div><div class="line">					<span class="keyword">if</span> (degree &lt; -PI)  </div><div class="line">						degree += <span class="number">2.0</span> * PI;  </div><div class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (degree &gt; PI)  </div><div class="line">						degree -= <span class="number">2.0</span> * PI;  </div><div class="line">					<span class="comment">//存储方向，可以直接利用检测到的链表进行该步主方向的指定;  </span></div><div class="line">					<span class="comment">//分配内存重新存储特征点  </span></div><div class="line">					Keypoint k;  </div><div class="line">					<span class="comment">/* Allocate memory for the keypoint Descriptor. */</span>  </div><div class="line">					k = (Keypoint) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> KeypointSt));  </div><div class="line">					k-&gt;next = keyDescriptors;  </div><div class="line">					keyDescriptors = k;  </div><div class="line">					k-&gt;descrip = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(LEN * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">					k-&gt;row = p-&gt;row;  </div><div class="line">					k-&gt;col = p-&gt;col;  </div><div class="line">					k-&gt;sy = p-&gt;sy;    <span class="comment">//行  </span></div><div class="line">					k-&gt;sx = p-&gt;sx;    <span class="comment">//列  </span></div><div class="line">					k-&gt;octave = p-&gt;octave;  </div><div class="line">					k-&gt;level = p-&gt;level;  </div><div class="line">					k-&gt;scale = p-&gt;scale;        </div><div class="line">					k-&gt;ori = degree;  </div><div class="line">					k-&gt;mag = peakValue;    </div><div class="line">				}<span class="comment">//for  </span></div><div class="line">				<span class="built_in">free</span>(orienthist);  </div><div class="line">		}  </div><div class="line">		p=p-&gt;next;  </div><div class="line">	}   </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//寻找与方向直方图最近的柱，确定其index   </span></div><div class="line"><span class="keyword">int</span> FindClosestRotationBin (<span class="keyword">int</span> binCount, <span class="keyword">float</span> angle)  </div><div class="line">{  </div><div class="line">	angle += CV_PI;  </div><div class="line">	angle /= <span class="number">2.0</span> * CV_PI;  </div><div class="line">	<span class="comment">// calculate the aligned bin  </span></div><div class="line">	angle *= binCount;  </div><div class="line">	<span class="keyword">int</span> idx = (<span class="keyword">int</span>) angle;  </div><div class="line">	<span class="keyword">if</span> (idx == binCount)  </div><div class="line">		idx = <span class="number">0</span>;  </div><div class="line">	<span class="keyword">return</span> (idx);  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// Average the content of the direction bins.  </span></div><div class="line"><span class="keyword">void</span> AverageWeakBins (<span class="keyword">double</span>* hist, <span class="keyword">int</span> binCount)  </div><div class="line">{  </div><div class="line">	<span class="comment">// TODO: make some tests what number of passes is the best. (its clear  </span></div><div class="line">	<span class="comment">// one is not enough, as we may have something like  </span></div><div class="line">	<span class="comment">// ( 0.4, 0.4, 0.3, 0.4, 0.4 ))  </span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> sn = <span class="number">0</span> ; sn &lt; <span class="number">2</span> ; ++sn)   </div><div class="line">	{  </div><div class="line">		<span class="keyword">double</span> firstE = hist[<span class="number">0</span>];  </div><div class="line">		<span class="keyword">double</span> last = hist[binCount-<span class="number">1</span>];  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> sw = <span class="number">0</span> ; sw &lt; binCount ; ++sw)   </div><div class="line">		{  </div><div class="line">			<span class="keyword">double</span> cur = hist[sw];  </div><div class="line">			<span class="keyword">double</span> next = (sw == (binCount - <span class="number">1</span>)) ? firstE : hist[(sw + <span class="number">1</span>) % binCount];  </div><div class="line">			hist[sw] = (last + cur + next) / <span class="number">3.0</span>;  </div><div class="line">			last = cur;  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">// Fit a parabol to the three points (-1.0 ; left), (0.0 ; middle) and  </span></div><div class="line"><span class="comment">// (1.0 ; right).  </span></div><div class="line"><span class="comment">// Formulas:  </span></div><div class="line"><span class="comment">// f(x) = a (x - c)^2 + b  </span></div><div class="line"><span class="comment">// c is the peak offset (where f'(x) is zero), b is the peak value.  </span></div><div class="line"><span class="comment">// In case there is an error false is returned, otherwise a correction  </span></div><div class="line"><span class="comment">// value between [-1 ; 1] is returned in 'degreeCorrection', where -1  </span></div><div class="line"><span class="comment">// means the peak is located completely at the left vector, and -0.5 just  </span></div><div class="line"><span class="comment">// in the middle between left and middle and &gt; 0 to the right side. In  </span></div><div class="line"><span class="comment">// 'peakValue' the maximum estimated peak value is stored.  </span></div><div class="line"><span class="keyword">bool</span> InterpolateOrientation (<span class="keyword">double</span> left, <span class="keyword">double</span> middle,<span class="keyword">double</span> right, <span class="keyword">double</span> *degreeCorrection, <span class="keyword">double</span> *peakValue)  </div><div class="line">{  </div><div class="line">	<span class="keyword">double</span> a = ((left + right) - <span class="number">2.0</span> * middle) / <span class="number">2.0</span>;   <span class="comment">//抛物线捏合系数a  </span></div><div class="line">	<span class="comment">// degreeCorrection = peakValue = Double.NaN;  </span></div><div class="line"></div><div class="line">	<span class="comment">// Not a parabol  </span></div><div class="line">	<span class="keyword">if</span> (a == <span class="number">0.0</span>)  </div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">	<span class="keyword">double</span> c = (((left - middle) / a) - <span class="number">1.0</span>) / <span class="number">2.0</span>;  </div><div class="line">	<span class="keyword">double</span> b = middle - c * c * a;  </div><div class="line">	<span class="keyword">if</span> (c &lt; -<span class="number">0.5</span> || c &gt; <span class="number">0.5</span>)  </div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">	*degreeCorrection = c;  </div><div class="line">	*peakValue = b;  </div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//显示特征点处的主方向  </span></div><div class="line"><span class="keyword">void</span> DisplayOrientation (IplImage* image, ImageOctaves *GaussianPyr)  </div><div class="line">{  </div><div class="line">	Keypoint p = keyDescriptors; <span class="comment">// p指向第一个结点  </span></div><div class="line">	<span class="keyword">while</span>(p) <span class="comment">// 没到表尾  </span></div><div class="line">	{  </div><div class="line">		<span class="keyword">float</span> scale=(GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma;  </div><div class="line">		<span class="keyword">float</span> autoscale = <span class="number">3.0</span>;   </div><div class="line">		<span class="keyword">float</span> uu=autoscale*scale*<span class="built_in">cos</span>(p-&gt;ori);  </div><div class="line">		<span class="keyword">float</span> vv=autoscale*scale*<span class="built_in">sin</span>(p-&gt;ori);  </div><div class="line">		<span class="keyword">float</span> x=(p-&gt;col)+uu;  </div><div class="line">		<span class="keyword">float</span> y=(p-&gt;row)+vv;  </div><div class="line">		cvLine( image, cvPoint((<span class="keyword">int</span>)(p-&gt;col),(<span class="keyword">int</span>)(p-&gt;row)),   </div><div class="line">			cvPoint((<span class="keyword">int</span>)x,(<span class="keyword">int</span>)y), CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),  </div><div class="line">			<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );  </div><div class="line">		<span class="comment">// Arrow head parameters  </span></div><div class="line">		<span class="keyword">float</span> alpha = <span class="number">0.33</span>; <span class="comment">// Size of arrow head relative to the length of the vector  </span></div><div class="line">		<span class="keyword">float</span> beta = <span class="number">0.33</span>;  <span class="comment">// Width of the base of the arrow head relative to the length  </span></div><div class="line"></div><div class="line">		<span class="keyword">float</span> xx0= (p-&gt;col)+uu-alpha*(uu+beta*vv);  </div><div class="line">		<span class="keyword">float</span> yy0= (p-&gt;row)+vv-alpha*(vv-beta*uu);  </div><div class="line">		<span class="keyword">float</span> xx1= (p-&gt;col)+uu-alpha*(uu-beta*vv);  </div><div class="line">		<span class="keyword">float</span> yy1= (p-&gt;row)+vv-alpha*(vv+beta*uu);  </div><div class="line">		cvLine( image, cvPoint((<span class="keyword">int</span>)xx0,(<span class="keyword">int</span>)yy0),   </div><div class="line">			cvPoint((<span class="keyword">int</span>)x,(<span class="keyword">int</span>)y), CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),  </div><div class="line">			<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );  </div><div class="line">		cvLine( image, cvPoint((<span class="keyword">int</span>)xx1,(<span class="keyword">int</span>)yy1),   </div><div class="line">			cvPoint((<span class="keyword">int</span>)x,(<span class="keyword">int</span>)y), CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),  </div><div class="line">			<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span> );  </div><div class="line">		p=p-&gt;next;  </div><div class="line">	}   </div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="SIFT算法第五步"><strong>SIFT算法第五步</strong></h4>
<p>SIFT算法第五步：抽取各个特征点处的特征描述字，确定特征点的描述字。描述字是Patch网格内梯度方向的描述，旋转网格到主方向，插值得到网格处梯度值。</p>
<p>一个特征点可以用2<em>2</em>8=32维的向量，也可以用4<em>4</em>8=128维的向量更精确的进行描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ExtractFeatureDescriptors(<span class="keyword">int</span> numoctaves, ImageOctaves *GaussianPyr)  </div><div class="line">{  </div><div class="line">	<span class="comment">// The orientation histograms have 8 bins  </span></div><div class="line">	<span class="keyword">float</span> orient_bin_spacing = PI/<span class="number">4</span>;  </div><div class="line">	<span class="keyword">float</span> orient_angles[<span class="number">8</span>]={-PI,-PI+orient_bin_spacing,-PI*<span class="number">0.5</span>, -orient_bin_spacing,  </div><div class="line">		<span class="number">0.0</span>, orient_bin_spacing, PI*<span class="number">0.5</span>,  PI+orient_bin_spacing};  </div><div class="line">	<span class="comment">//产生描述字中心各点坐标  </span></div><div class="line">	<span class="keyword">float</span> *feat_grid=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">2</span>*<span class="number">16</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;GridSpacing;i++)  </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*GridSpacing;++j,++j)  </div><div class="line">		{  </div><div class="line">			feat_grid[i*<span class="number">2</span>*GridSpacing+j]=-<span class="number">6.0</span>+i*GridSpacing;  </div><div class="line">			feat_grid[i*<span class="number">2</span>*GridSpacing+j+<span class="number">1</span>]=-<span class="number">6.0</span>+<span class="number">0.5</span>*j*GridSpacing;  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="comment">//产生网格  </span></div><div class="line">	<span class="keyword">float</span> *feat_samples=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">2</span>*<span class="number">256</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">4</span>*GridSpacing;i++)  </div><div class="line">	{  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>*GridSpacing;j+=<span class="number">2</span>)  </div><div class="line">		{  </div><div class="line">			feat_samples[i*<span class="number">8</span>*GridSpacing+j]=-(<span class="number">2</span>*GridSpacing-<span class="number">0.5</span>)+i;  </div><div class="line">			feat_samples[i*<span class="number">8</span>*GridSpacing+j+<span class="number">1</span>]=-(<span class="number">2</span>*GridSpacing-<span class="number">0.5</span>)+<span class="number">0.5</span>*j;  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="keyword">float</span> feat_window = <span class="number">2</span>*GridSpacing;  </div><div class="line">	Keypoint p = keyDescriptors; <span class="comment">// p指向第一个结点  </span></div><div class="line">	<span class="keyword">while</span>(p) <span class="comment">// 没到表尾  </span></div><div class="line">	{  </div><div class="line">		<span class="keyword">float</span> scale=(GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma;  </div><div class="line"></div><div class="line">		<span class="keyword">float</span> sine = <span class="built_in">sin</span>(p-&gt;ori);  </div><div class="line">		<span class="keyword">float</span> cosine = <span class="built_in">cos</span>(p-&gt;ori);    </div><div class="line">		<span class="comment">//计算中心点坐标旋转之后的位置  </span></div><div class="line">		<span class="keyword">float</span> *featcenter=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">2</span>*<span class="number">16</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;GridSpacing;i++)  </div><div class="line">		{  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*GridSpacing;j+=<span class="number">2</span>)  </div><div class="line">			{  </div><div class="line">				<span class="keyword">float</span> x=feat_grid[i*<span class="number">2</span>*GridSpacing+j];  </div><div class="line">				<span class="keyword">float</span> y=feat_grid[i*<span class="number">2</span>*GridSpacing+j+<span class="number">1</span>];  </div><div class="line">				featcenter[i*<span class="number">2</span>*GridSpacing+j]=((cosine * x + sine * y) + p-&gt;sx);  </div><div class="line">				featcenter[i*<span class="number">2</span>*GridSpacing+j+<span class="number">1</span>]=((-sine * x + cosine * y) + p-&gt;sy);  </div><div class="line">			}  </div><div class="line">		}  </div><div class="line">		<span class="comment">// calculate sample window coordinates (rotated along keypoint)  </span></div><div class="line">		<span class="keyword">float</span> *feat=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">2</span>*<span class="number">256</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">		<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">64</span>*GridSpacing;i++,i++)  </div><div class="line">		{  </div><div class="line">			<span class="keyword">float</span> x=feat_samples[i];  </div><div class="line">			<span class="keyword">float</span> y=feat_samples[i+<span class="number">1</span>];  </div><div class="line">			feat[i]=((cosine * x + sine * y) + p-&gt;sx);  </div><div class="line">			feat[i+<span class="number">1</span>]=((-sine * x + cosine * y) + p-&gt;sy);  </div><div class="line">		}  </div><div class="line">		<span class="comment">//Initialize the feature descriptor.  </span></div><div class="line">		<span class="keyword">float</span> *feat_desc = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">128</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)  </div><div class="line">		{  </div><div class="line">			feat_desc[i]=<span class="number">0.0</span>;  </div><div class="line">			<span class="comment">// printf("%f  ",feat_desc[i]);    </span></div><div class="line">		}  </div><div class="line">		<span class="comment">//printf("/n");  </span></div><div class="line">		<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">512</span>;++i,++i)  </div><div class="line">		{  </div><div class="line">			<span class="keyword">float</span> x_sample = feat[i];  </div><div class="line">			<span class="keyword">float</span> y_sample = feat[i+<span class="number">1</span>];  </div><div class="line">			<span class="comment">// Interpolate the gradient at the sample position  </span></div><div class="line">			<span class="comment">/* </span></div><div class="line">			0   1   0 </div><div class="line">			1   *   1 </div><div class="line">			0   1   0   具体插值策略如图示 </div><div class="line">			*/  </div><div class="line">			<span class="keyword">float</span> sample12=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample-<span class="number">1</span>);  </div><div class="line">			<span class="keyword">float</span> sample21=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample-<span class="number">1</span>, y_sample);   </div><div class="line">			<span class="keyword">float</span> sample22=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample);   </div><div class="line">			<span class="keyword">float</span> sample23=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample+<span class="number">1</span>, y_sample);   </div><div class="line">			<span class="keyword">float</span> sample32=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample+<span class="number">1</span>);   </div><div class="line">			<span class="comment">//float diff_x = 0.5*(sample23 - sample21);  </span></div><div class="line">			<span class="comment">//float diff_y = 0.5*(sample32 - sample12);  </span></div><div class="line">			<span class="keyword">float</span> diff_x = sample23 - sample21;  </div><div class="line">			<span class="keyword">float</span> diff_y = sample32 - sample12;  </div><div class="line">			<span class="keyword">float</span> mag_sample = <span class="built_in">sqrt</span>( diff_x*diff_x + diff_y*diff_y );  </div><div class="line">			<span class="keyword">float</span> grad_sample = <span class="built_in">atan</span>( diff_y / diff_x );  </div><div class="line">			<span class="keyword">if</span>(grad_sample == CV_PI)  </div><div class="line">				grad_sample = -CV_PI;  </div><div class="line">			<span class="comment">// Compute the weighting for the x and y dimensions.  </span></div><div class="line">			<span class="keyword">float</span> *x_wght=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( GridSpacing * GridSpacing * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">			<span class="keyword">float</span> *y_wght=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( GridSpacing * GridSpacing * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </div><div class="line">			<span class="keyword">float</span> *pos_wght=(<span class="keyword">float</span> *) <span class="built_in">malloc</span>( <span class="number">8</span>*GridSpacing * GridSpacing * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));;  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;<span class="number">32</span>;++m,++m)  </div><div class="line">			{  </div><div class="line">				<span class="keyword">float</span> x=featcenter[m];  </div><div class="line">				<span class="keyword">float</span> y=featcenter[m+<span class="number">1</span>];  </div><div class="line">				x_wght[m/<span class="number">2</span>] = max(<span class="number">1</span> - (<span class="built_in">fabs</span>(x - x_sample)*<span class="number">1.0</span>/GridSpacing), <span class="number">0</span>);  </div><div class="line">				y_wght[m/<span class="number">2</span>] = max(<span class="number">1</span> - (<span class="built_in">fabs</span>(y - y_sample)*<span class="number">1.0</span>/GridSpacing), <span class="number">0</span>);   </div><div class="line"></div><div class="line">			}  </div><div class="line">			<span class="keyword">for</span> ( m=<span class="number">0</span>;m&lt;<span class="number">16</span>;++m)  </div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;<span class="number">8</span>;++n)  </div><div class="line">					pos_wght[m*<span class="number">8</span>+n]=x_wght[m]*y_wght[m];  </div><div class="line">			<span class="built_in">free</span>(x_wght);  </div><div class="line">			<span class="built_in">free</span>(y_wght);  </div><div class="line">			<span class="comment">//计算方向的加权，首先旋转梯度场到主方向，然后计算差异   </span></div><div class="line">			<span class="keyword">float</span> diff[<span class="number">8</span>],orient_wght[<span class="number">128</span>];  </div><div class="line">			<span class="keyword">for</span> ( m=<span class="number">0</span>;m&lt;<span class="number">8</span>;++m)  </div><div class="line">			{   </div><div class="line">				<span class="keyword">float</span> angle = grad_sample-(p-&gt;ori)-orient_angles[m]+CV_PI;  </div><div class="line">				<span class="keyword">float</span> temp = angle / (<span class="number">2.0</span> * CV_PI);  </div><div class="line">				angle -= (<span class="keyword">int</span>)(temp) * (<span class="number">2.0</span> * CV_PI);  </div><div class="line">				diff[m]= angle - CV_PI;  </div><div class="line">			}  </div><div class="line">			<span class="comment">// Compute the gaussian weighting.  </span></div><div class="line">			<span class="keyword">float</span> x=p-&gt;sx;  </div><div class="line">			<span class="keyword">float</span> y=p-&gt;sy;  </div><div class="line">			<span class="keyword">float</span> g = <span class="built_in">exp</span>(-((x_sample-x)*(x_sample-x)+(y_sample-y)*(y_sample-y))/(<span class="number">2</span>*feat_window*feat_window))/(<span class="number">2</span>*CV_PI*feat_window*feat_window);  </div><div class="line"></div><div class="line">			<span class="keyword">for</span> ( m=<span class="number">0</span>;m&lt;<span class="number">128</span>;++m)  </div><div class="line">			{  </div><div class="line">				orient_wght[m] = max((<span class="number">1.0</span> - <span class="number">1.0</span>*<span class="built_in">fabs</span>(diff[m%<span class="number">8</span>])/orient_bin_spacing),<span class="number">0</span>);  </div><div class="line">				feat_desc[m] = feat_desc[m] + orient_wght[m]*pos_wght[m]*g*mag_sample;  </div><div class="line">			}  </div><div class="line">			<span class="built_in">free</span>(pos_wght);     </div><div class="line">		}  </div><div class="line">		<span class="built_in">free</span>(feat);  </div><div class="line">		<span class="built_in">free</span>(featcenter);  </div><div class="line">		<span class="keyword">float</span> norm=GetVecNorm( feat_desc, <span class="number">128</span>);  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;<span class="number">128</span>;m++)  </div><div class="line">		{  </div><div class="line">			feat_desc[m]/=norm;  </div><div class="line">			<span class="keyword">if</span> (feat_desc[m]&gt;<span class="number">0.2</span>)  </div><div class="line">				feat_desc[m]=<span class="number">0.2</span>;  </div><div class="line">		}  </div><div class="line">		norm=GetVecNorm( feat_desc, <span class="number">128</span>);  </div><div class="line">		<span class="keyword">for</span> ( m=<span class="number">0</span>;m&lt;<span class="number">128</span>;m++)  </div><div class="line">		{  </div><div class="line">			feat_desc[m]/=norm;  </div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%f  "</span>,feat_desc[m]);    </div><div class="line">		}  </div><div class="line">		<span class="built_in">printf</span>(<span class="string">"/n"</span>);  </div><div class="line">		p-&gt;descrip = feat_desc;  </div><div class="line">		p=p-&gt;next;  </div><div class="line">	}  </div><div class="line">	<span class="built_in">free</span>(feat_grid);  </div><div class="line">	<span class="built_in">free</span>(feat_samples);  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//为了显示图象金字塔，而作的图像水平拼接  </span></div><div class="line">CvMat* MosaicHorizen( CvMat* im1, CvMat* im2 )  </div><div class="line">{  </div><div class="line">	<span class="keyword">int</span> row,col;  </div><div class="line">	CvMat *mosaic = cvCreateMat( max(im1-&gt;rows,im2-&gt;rows),(im1-&gt;cols+im2-&gt;cols),CV_32FC1);  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	cvZero(mosaic);  </div><div class="line">	<span class="comment">/* Copy images into mosaic1. */</span>  </div><div class="line">	<span class="keyword">for</span> ( row = <span class="number">0</span>; row &lt; im1-&gt;rows; row++)  </div><div class="line">		<span class="keyword">for</span> ( col = <span class="number">0</span>; col &lt; im1-&gt;cols; col++)  </div><div class="line">			Mosaic(row,col)=Im11Mat(row,col) ;  </div><div class="line">	<span class="keyword">for</span> (  row = <span class="number">0</span>; row &lt; im2-&gt;rows; row++)  </div><div class="line">		<span class="keyword">for</span> (  col = <span class="number">0</span>; col &lt; im2-&gt;cols; col++)  </div><div class="line">			Mosaic(row, (col+im1-&gt;cols) )= Im22Mat(row,col) ;  </div><div class="line">	<span class="keyword">return</span> mosaic;  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="comment">//为了显示图象金字塔，而作的图像垂直拼接  </span></div><div class="line">CvMat* MosaicVertical( CvMat* im1, CvMat* im2 )  </div><div class="line">{  </div><div class="line">	<span class="keyword">int</span> row,col;  </div><div class="line">	CvMat *mosaic = cvCreateMat(im1-&gt;rows+im2-&gt;rows,max(im1-&gt;cols,im2-&gt;cols), CV_32FC1);  </div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	cvZero(mosaic);  </div><div class="line"></div><div class="line">	<span class="comment">/* Copy images into mosaic1. */</span>  </div><div class="line">	<span class="keyword">for</span> ( row = <span class="number">0</span>; row &lt; im1-&gt;rows; row++)  </div><div class="line">		<span class="keyword">for</span> ( col = <span class="number">0</span>; col &lt; im1-&gt;cols; col++)  </div><div class="line">			Mosaic(row,col)= Im11Mat(row,col) ;  </div><div class="line">	<span class="keyword">for</span> ( row = <span class="number">0</span>; row &lt; im2-&gt;rows; row++)  </div><div class="line">		<span class="keyword">for</span> ( col = <span class="number">0</span>; col &lt; im2-&gt;cols; col++)  </div><div class="line">			Mosaic((row+im1-&gt;rows),col)=Im22Mat(row,col) ;  </div><div class="line"></div><div class="line">	<span class="keyword">return</span> mosaic;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>ok，为了版述清晰，再贴一下上文所述的主函数（注，上文已贴出，此是为了版述清晰，重复造轮）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main( <span class="keyword">void</span> )  </div><div class="line">{  </div><div class="line">	<span class="comment">//声明当前帧IplImage指针  </span></div><div class="line">	IplImage* src = NULL;   </div><div class="line">	IplImage* image1 = NULL;   </div><div class="line">	IplImage* grey_im1 = NULL;   </div><div class="line">	IplImage* DoubleSizeImage = NULL;  </div><div class="line"></div><div class="line">	IplImage* mosaic1 = NULL;   </div><div class="line">	IplImage* mosaic2 = NULL;   </div><div class="line"></div><div class="line">	CvMat* mosaicHorizen1 = NULL;  </div><div class="line">	CvMat* mosaicHorizen2 = NULL;  </div><div class="line">	CvMat* mosaicVertical1 = NULL;  </div><div class="line"></div><div class="line">	CvMat* image1Mat = NULL;  </div><div class="line">	CvMat* tempMat=NULL;  </div><div class="line"></div><div class="line">	ImageOctaves *Gaussianpyr;  </div><div class="line">	<span class="keyword">int</span> rows,cols;  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im1Mat(ROW,COL) ((float *)(image1Mat-&gt;data.fl + image1Mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line"></div><div class="line">	<span class="comment">//灰度图象像素的数据结构  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im1B(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im1G(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3+1]  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> Im1R(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3+2]  </span></div><div class="line"></div><div class="line">	storage = cvCreateMemStorage(<span class="number">0</span>);   </div><div class="line"></div><div class="line">	<span class="comment">//读取图片  </span></div><div class="line">	<span class="keyword">if</span>( (src = cvLoadImage( <span class="string">"street1.jpg"</span>, <span class="number">1</span>)) == <span class="number">0</span> )  <span class="comment">// test1.jpg einstein.pgm back1.bmp  </span></div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line"></div><div class="line">	<span class="comment">//为图像分配内存   </span></div><div class="line">	image1 = cvCreateImage(cvSize(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="number">3</span>);  </div><div class="line">	grey_im1 = cvCreateImage(cvSize(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="number">1</span>);  </div><div class="line">	DoubleSizeImage = cvCreateImage(cvSize(<span class="number">2</span>*(src-&gt;width), <span class="number">2</span>*(src-&gt;height)),  IPL_DEPTH_8U,<span class="number">3</span>);  </div><div class="line"></div><div class="line">	<span class="comment">//为图像阵列分配内存，假设两幅图像的大小相同，tempMat跟随image1的大小  </span></div><div class="line">	image1Mat = cvCreateMat(src-&gt;height, src-&gt;width, CV_32FC1);  </div><div class="line">	<span class="comment">//转化成单通道图像再处理  </span></div><div class="line">	cvCvtColor(src, grey_im1, CV_BGR2GRAY);  </div><div class="line">	<span class="comment">//转换进入Mat数据结构,图像操作使用的是浮点型操作  </span></div><div class="line">	cvConvert(grey_im1, image1Mat);  </div><div class="line"></div><div class="line">	<span class="keyword">double</span> t = (<span class="keyword">double</span>)cvGetTickCount();  </div><div class="line">	<span class="comment">//图像归一化  </span></div><div class="line">	cvConvertScale( image1Mat, image1Mat, <span class="number">1.0</span>/<span class="number">255</span>, <span class="number">0</span> );  </div><div class="line"></div><div class="line">	<span class="keyword">int</span> dim = min(image1Mat-&gt;rows, image1Mat-&gt;cols);  </div><div class="line">	numoctaves = (<span class="keyword">int</span>) (<span class="built_in">log</span>((<span class="keyword">double</span>) dim) / <span class="built_in">log</span>(<span class="number">2.0</span>)) - <span class="number">2</span>;    <span class="comment">//金字塔阶数  </span></div><div class="line">	numoctaves = min(numoctaves, MAXOCTAVES);  </div><div class="line"></div><div class="line">	<span class="comment">//SIFT算法第一步，预滤波除噪声，建立金字塔底层  </span></div><div class="line">	tempMat = ScaleInitImage(image1Mat) ;  </div><div class="line">	<span class="comment">//SIFT算法第二步，建立Guassian金字塔和DOG金字塔  </span></div><div class="line">	Gaussianpyr = BuildGaussianOctaves(tempMat) ;  </div><div class="line"></div><div class="line">	t = (<span class="keyword">double</span>)cvGetTickCount() - t;  </div><div class="line">	<span class="built_in">printf</span>( <span class="string">"the time of build Gaussian pyramid and DOG pyramid is %.1f/n"</span>, t/(cvGetTickFrequency()*<span class="number">1000.</span>) );  </div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span></div><div class="line">	<span class="comment">//显示高斯金字塔  </span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numoctaves;i++)  </div><div class="line">	{  </div><div class="line">		<span class="keyword">if</span> (i==<span class="number">0</span>)  </div><div class="line">		{  </div><div class="line">			mosaicHorizen1=MosaicHorizen( (Gaussianpyr[<span class="number">0</span>].Octave)[<span class="number">0</span>].Level, (Gaussianpyr[<span class="number">0</span>].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">3</span>;j++)  </div><div class="line">				mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (Gaussianpyr[<span class="number">0</span>].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen1=halfSizeImage(mosaicHorizen1);  </div><div class="line">		}  </div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>)  </div><div class="line">		{  </div><div class="line">			mosaicHorizen2=MosaicHorizen( (Gaussianpyr[<span class="number">1</span>].Octave)[<span class="number">0</span>].Level, (Gaussianpyr[<span class="number">1</span>].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">3</span>;j++)  </div><div class="line">				mosaicHorizen2=MosaicHorizen( mosaicHorizen2, (Gaussianpyr[<span class="number">1</span>].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen2=halfSizeImage(mosaicHorizen2);  </div><div class="line">			mosaicVertical1=MosaicVertical( mosaicHorizen1, mosaicHorizen2 );  </div><div class="line">		}  </div><div class="line">		<span class="keyword">else</span>  </div><div class="line">		{  </div><div class="line">			mosaicHorizen1=MosaicHorizen( (Gaussianpyr[i].Octave)[<span class="number">0</span>].Level, (Gaussianpyr[i].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">3</span>;j++)  </div><div class="line">				mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (Gaussianpyr[i].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen1=halfSizeImage(mosaicHorizen1);  </div><div class="line">			mosaicVertical1=MosaicVertical( mosaicVertical1, mosaicHorizen1 );  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	mosaic1 = cvCreateImage(cvSize(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="number">1</span>);  </div><div class="line">	cvConvertScale( mosaicVertical1, mosaicVertical1, <span class="number">255.0</span>, <span class="number">0</span> );  </div><div class="line">	cvConvertScaleAbs( mosaicVertical1, mosaic1, <span class="number">1</span>, <span class="number">0</span> );  </div><div class="line"></div><div class="line">	<span class="comment">//  cvSaveImage("GaussianPyramid of me.jpg",mosaic1);  </span></div><div class="line">	cvNamedWindow(<span class="string">"mosaic1"</span>,<span class="number">1</span>);  </div><div class="line">	cvShowImage(<span class="string">"mosaic1"</span>, mosaic1);  </div><div class="line">	cvWaitKey(<span class="number">0</span>);  </div><div class="line">	cvDestroyWindow(<span class="string">"mosaic1"</span>);  </div><div class="line">	<span class="comment">//显示DOG金字塔  </span></div><div class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;numoctaves;i++)  </div><div class="line">	{  </div><div class="line">		<span class="keyword">if</span> (i==<span class="number">0</span>)  </div><div class="line">		{  </div><div class="line">			mosaicHorizen1=MosaicHorizen( (DOGoctaves[<span class="number">0</span>].Octave)[<span class="number">0</span>].Level, (DOGoctaves[<span class="number">0</span>].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">2</span>;j++)  </div><div class="line">				mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (DOGoctaves[<span class="number">0</span>].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen1=halfSizeImage(mosaicHorizen1);  </div><div class="line">		}  </div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>)  </div><div class="line">		{  </div><div class="line">			mosaicHorizen2=MosaicHorizen( (DOGoctaves[<span class="number">1</span>].Octave)[<span class="number">0</span>].Level, (DOGoctaves[<span class="number">1</span>].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">2</span>;j++)  </div><div class="line">				mosaicHorizen2=MosaicHorizen( mosaicHorizen2, (DOGoctaves[<span class="number">1</span>].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen2=halfSizeImage(mosaicHorizen2);  </div><div class="line">			mosaicVertical1=MosaicVertical( mosaicHorizen1, mosaicHorizen2 );  </div><div class="line">		}  </div><div class="line">		<span class="keyword">else</span>  </div><div class="line">		{  </div><div class="line">			mosaicHorizen1=MosaicHorizen( (DOGoctaves[i].Octave)[<span class="number">0</span>].Level, (DOGoctaves[i].Octave)[<span class="number">1</span>].Level );  </div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;SCALESPEROCTAVE+<span class="number">2</span>;j++)  </div><div class="line">				mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (DOGoctaves[i].Octave)[j].Level );  </div><div class="line">			<span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;NUMSIZE;j++)  </div><div class="line">				mosaicHorizen1=halfSizeImage(mosaicHorizen1);  </div><div class="line">			mosaicVertical1=MosaicVertical( mosaicVertical1, mosaicHorizen1 );  </div><div class="line">		}  </div><div class="line">	}  </div><div class="line">	<span class="comment">//考虑到DOG金字塔各层图像都会有正负，所以，必须寻找最负的，以将所有图像抬高一个台阶去显示  </span></div><div class="line">	<span class="keyword">double</span> min_val=<span class="number">0</span>;  </div><div class="line">	<span class="keyword">double</span> max_val=<span class="number">0</span>;  </div><div class="line">	cvMinMaxLoc( mosaicVertical1, &min_val, &max_val,NULL, NULL, NULL );  </div><div class="line">	<span class="keyword">if</span> ( min_val&lt;<span class="number">0.0</span> )  </div><div class="line">		cvAddS( mosaicVertical1, cvScalarAll( (-<span class="number">1.0</span>)*min_val ), mosaicVertical1, NULL );  </div><div class="line">	mosaic2 = cvCreateImage(cvSize(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="number">1</span>);  </div><div class="line">	cvConvertScale( mosaicVertical1, mosaicVertical1, <span class="number">255.0</span>/(max_val-min_val), <span class="number">0</span> );  </div><div class="line">	cvConvertScaleAbs( mosaicVertical1, mosaic2, <span class="number">1</span>, <span class="number">0</span> );  </div><div class="line"></div><div class="line">	<span class="comment">//  cvSaveImage("DOGPyramid of me.jpg",mosaic2);  </span></div><div class="line">	cvNamedWindow(<span class="string">"mosaic1"</span>,<span class="number">1</span>);  </div><div class="line">	cvShowImage(<span class="string">"mosaic1"</span>, mosaic2);  </div><div class="line">	cvWaitKey(<span class="number">0</span>);  </div><div class="line"></div><div class="line">	<span class="comment">//SIFT算法第三步：特征点位置检测，最后确定特征点的位置  </span></div><div class="line">	<span class="keyword">int</span> keycount=DetectKeypoint(numoctaves, Gaussianpyr);  </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"the keypoints number are %d ;/n"</span>, keycount);  </div><div class="line">	cvCopy(src,image1,NULL);  </div><div class="line">	DisplayKeypointLocation( image1 ,Gaussianpyr);  </div><div class="line"></div><div class="line">	cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  </div><div class="line">	cvNamedWindow(<span class="string">"image1"</span>,<span class="number">1</span>);  </div><div class="line">	cvShowImage(<span class="string">"image1"</span>, DoubleSizeImage);  </div><div class="line">	cvWaitKey(<span class="number">0</span>);    </div><div class="line">	cvDestroyWindow(<span class="string">"image1"</span>);  </div><div class="line"></div><div class="line">	<span class="comment">//SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向  </span></div><div class="line">	ComputeGrad_DirecandMag(numoctaves, Gaussianpyr);  </div><div class="line">	AssignTheMainOrientation( numoctaves, Gaussianpyr,mag_pyr,grad_pyr);  </div><div class="line">	cvCopy(src,image1,NULL);  </div><div class="line">	DisplayOrientation ( image1, Gaussianpyr);  </div><div class="line"></div><div class="line">	<span class="comment">//  cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  </span></div><div class="line">	cvNamedWindow(<span class="string">"image1"</span>,<span class="number">1</span>);  </div><div class="line">	<span class="comment">//  cvResizeWindow("image1", 2*(image1-&gt;width), 2*(image1-&gt;height) );  </span></div><div class="line">	cvShowImage(<span class="string">"image1"</span>, image1);  </div><div class="line">	cvWaitKey(<span class="number">0</span>);  </div><div class="line"></div><div class="line">	<span class="comment">//SIFT算法第五步：抽取各个特征点处的特征描述字  </span></div><div class="line">	ExtractFeatureDescriptors( numoctaves, Gaussianpyr);  </div><div class="line">	cvWaitKey(<span class="number">0</span>);  </div><div class="line"></div><div class="line">	<span class="comment">//销毁窗口  </span></div><div class="line">	cvDestroyWindow(<span class="string">"image1"</span>);  </div><div class="line">	cvDestroyWindow(<span class="string">"mosaic1"</span>);  </div><div class="line">	<span class="comment">//释放图像  </span></div><div class="line">	cvReleaseImage(&image1);  </div><div class="line">	cvReleaseImage(&grey_im1);  </div><div class="line">	cvReleaseImage(&mosaic1);  </div><div class="line">	cvReleaseImage(&mosaic2);  </div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后，再看一下，运行效果（图中美女为老乡+朋友，何姐08年照）：</p>
<p><img src="../images/10/10.1.3/10.1.3.1.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.2.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.3.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.4.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.5.jpg" alt=""></p>
<p>完。</p>
<p><strong>updated</strong></p>
<p>有很多朋友都在本文评论下要求要本程序的完整源码包（注：本文代码未贴全，复制粘贴编译肯定诸多错误），但由于时隔太久，这份代码我自己也找不到了，不过，我可以提供一份sift + KD + BBF，且可以编译正确的代码供大家参考学习，有pudn帐号的朋友可以前去下载：<a href="tp://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html" target="_blank" rel="external">http://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html </a>（没有pudn账号的同学请加群：169056165，验证信息：sift，至群共享下载），然后用两幅不同的图片做了下匹配（当然，运行结果显示是不匹配的），效果还不错：<a href="">http://weibo.com/1580904460/yDmzAEwcV#1348475194313</a>! July、二零一二年十月十一日。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>


<div class="article-share" id="share">

  <div data-url="http://qiaoidea.github.io/programing_art/ebook/zh/10.01.03.html" data-title="Qiaoidea&#39;s Blog" data-tsina="5288126184" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
	
<section id="comments" class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
        </div>
        <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 一时不学，差之毫厘； <br/>
			终日不学，失之千里。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5288126184" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2015 
		
		<a href="http://qiaoidea.github.io/about" target="_blank" title="Qiaoidea">Qiaoidea</a>
		
		</p>
</div>
</footer>
        <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"qiaoidea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

      </body>
     </html>
     
