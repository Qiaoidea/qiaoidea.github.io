
  
    <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Qiaoidea&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Qiaoidea">
    
    <meta name="description" content="Android">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Qiaoidea&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

      <body>
        <header>
          <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiaoidea&#39;s Blog" title="Qiaoidea&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiaoidea&#39;s Blog">Qiaoidea&#39;s Blog</a></h1>
				<h2 class="blog-motto">你必须非常努力，才能看起来毫不费力。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/dj">札记</a></li>
					
						<li><a href="/programing_art">编程艺术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qiaoidea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
        </header>
        <div id="container">
          <div id="main" class="page" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/programing_art/ebook/zh/木块砌墙原稿.html" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="http://qiaoidea.github.io/about" title="Qiaoidea" target="_blank" itemprop="author">Qiaoidea</a>
		
  <p class="article-time">
    <time datetime="2015-01-10T11:57:47.000Z" itemprop="datePublished"> 发表于 1月 10 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="木块砌墙">木块砌墙</h1>
<p>作者：July、caopengcs、红色标记。致谢：fuwutu、demo。</p>
<p>时间：二零一三年八月十二日</p>
<p><strong>题目</strong>：用 1×1×1, 1×2×1以及2×1×1的三种木块（横绿竖蓝，且绿蓝长度均为2），</p>
<p><img src="../images/32~33/33.1.png" alt=""></p>
<p>搭建高长宽分别为K × 2^N × 1的墙，不能翻转、旋转（其中，0&lt;=N&lt;=1024，1&lt;=K&lt;=4）</p>
<p><img src="../images/32~33/33.2.png" alt=""></p>
<p>有多少种方案，输出结果</p>
<p>对1000000007取模。</p>
<p>举个例子如给定高度和长度：N=1 K=2，则答案是7，即有7种搭法，如下图所示：</p>
<p><img src="../images/32~33/33.3.png" alt=""></p>
<p><strong>详解</strong>：此题很有意思，涉及的知识点也比较多，包括动态规划，快速矩阵幂，状态压缩，排列组合等等都一一考察了个遍。而且跟一个比较经典的矩阵乘法问题类似：即用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果</p>
<p><img src="../images/32~33/33.4.gif" alt=""></p>
<p>OK，回到正题。下文使用的图示说明(所有看到的都是横切面)：</p>
<p><img src="../images/32~33/33.5.jpg" alt=""></p>
<p>首先说明“？方块”的作用</p>
<p><img src="../images/32~33/33.6.jpg" alt=""></p>
<p>“？方块”，表示这个位置是空位置，可以任意摆放。</p>
<p>上图的意思就是，当右上角被绿色木块占用，此位置固定不变，其他位置任意摆放，在这种情况下的堆放方案数。</p>
<h3 id="解法一、穷举遍历">解法一、穷举遍历</h3>
<p>初看此题，你可能最先想到的思路便是穷举：用二维数组模拟墙，从左下角开始摆放，从左往右，从下往上，最后一个格子是右上角那个位置；每个格子把每种可以摆放木块都摆放一次，每堆满一次算一种用摆放方法。为了便于描述，为木块的每个格子进行编号：</p>
<p><img src="../images/32~33/33.7.jpg" alt=""></p>
<p>下面演示当n=1,k=2的算法过程（7种情况）：</p>
<p><img src="../images/32~33/33.8.jpg" alt=""></p>
<p>穷举遍历在数据规模比较小的情况下还撑得住，但在0&lt;=N&lt;=1024这样的数据规模下，此方法则立刻变得有心无力，因此我们得寻找更优化的解法。</p>
<h3 id="解法二、递归分解">解法二、递归分解</h3>
<p>递归求解就是把一个大问题，分解成小问题，逐个求解，然后再解决大问题。</p>
<h4 id="2-1、算法演示">2.1、算法演示</h4>
<p>假如有墙规模为(n,k)，如果从中间切开，被分为规模问(n-1,k)的两堵墙，那么被分开的墙和原墙有什么关系呢？我们首先来看一下几组演示。</p>
<h5 id="2-1-1、n=1，k=2的情况">2.1.1、n=1，k=2的情况</h5>
<p>首先演示，<strong>n=1,k=2</strong>时的情况，如下图2-1：</p>
<p><img src="../images/32~33/33.9.jpg" alt=""></p>
<p>图 2-1</p>
<p>上图2-1中：</p>
<p><img src="../images/32~33/33.10.jpg" alt=""><br>表示，左边墙的所有堆放方案数 <em> 右边墙所有堆放方案数 = 2 </em> 2 = 4</p>
<p><img src="../images/32~33/33.11.jpg" alt=""><br>表示，当切开处有一个横条的时候，空位置存在的堆放方案数。左边<em>右边 = 1</em>1 = 2；剩余两组以此类推。</p>
<p>这个是排列组合的知识。</p>
<h5 id="2-1-2、n=2，k=3的情况">2.1.2、n=2，k=3的情况</h5>
<p>其次，我们再来演示下面更具一般性的计算分解，即当<strong>n=2,k=3</strong>的情况，如下图2-2：</p>
<p><img src="../images/32~33/33.12.jpg" alt=""></p>
<p>图 2-2</p>
<p>再从分解的结果中，挑选一组进行分解演示：</p>
<p><img src="../images/32~33/33.13.jpg" alt=""></p>
<p>图 2-3</p>
<p>通过图2-2和图2-3的分解演示，可以说明，最终都是分解成一列求解。在逐级向上汇总。</p>
<h5 id="2-1-3、n=4，k=3的情况">2.1.3、n=4，k=3的情况</h5>
<p>我们再假设一堵墙n=4，k=3，也就是说，宽度是16，高度是3时，会有以下分解：</p>
<p><img src="../images/32~33/33.14.jpg" alt=""></p>
<p>图2-4</p>
<p>根据上面的分解的一个中间结果，再进行分解，如下：</p>
<p><img src="../images/32~33/33.15.jpg" alt=""></p>
<p>图2-5</p>
<p>通过上面图2-1~图2-5的演示可以明确如下几点：</p>
<p>1.假设f(n)用于计算问题，那么f(n)依赖于f(n-1)的多种情况。</p>
<p>2.切开处有什么特殊的地方呢？通过上面的演示，我们得知被切开的两堵墙从没有互相嵌入的木块（绿色木块）到全是互相连接的木块，相当于切口绿色木块的全排列（即有绿色或者没有绿色的所有排列），即有2^k种状态（比如k=2，且有绿色用1表示，没有绿色用0表示，那么就有00、01、10、11这4种状态）。根据排列组合的性质，把每一种状态下左右木墙堆放方案数相乘，再把所有乘积求和，就得到木墙的堆放结果数。以此类推，将问题逐步往下分解即可。</p>
<p>3.此外，从图2-5中可以看出，除了需要考虑切口绿色木块的状态，还需要考虑最左边一列和最右边一列的绿色木块状态。我们把这两种边界状态称为左边界状态和右边界状态，分别用leftState和rightState表示。 </p>
<p>且在观察图2-5被切分后，所有左边的墙，他们的左边界ls状态始终保持不变，右边界rs状态从0~maxState, maxState = 2^k-1（有绿色方块表示1，没有表示0；ls表示左边界状态，rs表示右边界状态）：</p>
<p><img src="../images/32~33/33.16.jpg" alt=""></p>
<p>图2-6</p>
<p>同样可以看出右边的墙的右边界状态保持不变，而左边界状态从0~maxState。要堆砌的木墙可以看做是左边界状态=0，和右边界状态=0的一堵墙。</p>
<p>有一点可能要特别说明下，即上文中说，有绿色方块的状态表示标为1，无绿色方块的状态表示标为0，特意又拿上图2-6标记了一些数字，以让绝大部分读者能看得一目了然，如下所示：</p>
<p><img src="../images/32~33/33.17.jpg" alt=""></p>
<p>图2-7</p>
<p>这下，你应该很清楚的看到，在上图中，左边木块的状态表示一律为010，右边木块的状态表示则是000~111（即从下至上开始计数，右边木块rs的状态用二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7）。</p>
<h4 id="2-2、计算公式">2.2、计算公式</h4>
<p>通过图2-4、图2-5、图2-6的分解过程，我们可以总结出下面公式（leftState=最左边边界状态，rightState=最右边边界状态）：</p>
<p><img src="../images/32~33/33.18.jpg" alt=""></p>
<p>即：</p>
<p><img src="../images/32~33/33.19.jpg" alt=""></p>
<p>接下来，分3点解释下上述公式：</p>
<p><strong>1</strong>、上述函数返回结果是当左边状态为=leftState，右边状态=rightState时木墙的堆砌方案数，相当于直接分解的左右状态都为0的情况，即直接分解f(n,k,0,0)即可。看到这，读者可能便有疑问了，既然直接分解f(n,k,0,0)即可，为何还要加leftstate和leftstate两个变量呢？回顾下2.1.3节中n=4，k=3的演示例子，即当n=4，k=3时，其分解过程即如下图（上文2.1.3节中的图2-4）</p>
<p><img src="../images/32~33/33.20.jpg" alt=""></p>
<p>也就是说，刚开始直接分解f(4,3,0,0)，即n=4，k=3，leftstate=0，rightstate=0，但分解过程中leftstate和rightstate皆从0变化到了maxstate，故才让函数的第3和第4个参数采用leftstate和rightstate这两个变量的形式，公式也就理所当然的写成了f(n,k,leftstate,rightstate)。</p>
<p><strong>2</strong>、然后我们再看下当n=4，k=3分解的一个中间结果，即给定如上图最下面部分中红色框框所框住的木块时：</p>
<p><img src="../images/32~33/33.21.jpg" alt=""></p>
<p>它用方程表示即为 f(2,3,2,5)，怎么得来的呢？其实还是又回到了上文2.1.3节中，当n=2，k=3 时（下图即为上文2.1.3节中的图2-5和图2-6）</p>
<p><img src="../images/32~33/33.22.jpg" alt=""></p>
<p><img src="../images/32~33/33.23.jpg" alt=""></p>
<p>左边界ls状态始终保持不变时，右边界rs状态从0~maxState；右边界状态保持不变时，而左边界状态从0~maxState。</p>
<p>故上述分解过程用方程式可表示为：</p>
<p><strong>f(2,3,2,5)  = f(1,3,2,0) * f(1,3,0,5)</strong></p>
<p><strong>+ f(1,3,2,1) * f(1,3,1,5)</strong></p>
<p><strong>+ f(1,3,2,2) * f(1,3,2,5)</strong></p>
<p><strong>+ f(1,3,2,3) * f(1,3,3,5)</strong></p>
<p><strong>+ f(1,3,2,4) * f(1,3,4,5)</strong></p>
<p><strong>+ f(1,3,2,5) * f(1,3,5,5)</strong></p>
<p><strong>+ f(1,3,2,6) * f(1,3,6,5)</strong></p>
<p><strong>+ f(1,3,2,7) * f(1,3,7,5)</strong></p>
<p>说白了，我们曾在2.1节中从图2-2到图2-6正推推导出了公式，然上述过程中，则又再倒推推了一遍公式进行了说明。</p>
<p><strong>3</strong>、最后，作者是怎么想到引入 leftstate 和rightstate 这两个变量的呢？如红色标记所说：”因为切开后，发现绿色条，在分开处不断的变化，当时也进入了死胡同，我就在想，蓝色的怎么办。后来才想明白，与蓝色无关。每一种变化就是一种状态，所以就想到了引入leftstate 和rightstate这两个变量。”</p>
<h4 id="2-3、参考代码">2.3、参考代码</h4>
<p>下面代码就是根据上面函数原理编写的。最终执行效率，n=1024,k=4 时，用时0.2800160秒（之前代码用的是字典作为缓存，用时在1.3秒左右，后来改为数组结果，性能大增）。””</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//copyright@红色标记 12/8/2013    </span></div><div class="line"><span class="comment">//updated@July 13/8/2013  </span></div><div class="line"><span class="keyword">using</span> System;    </div><div class="line"><span class="keyword">using</span> System.Collections.Generic;    </div><div class="line"><span class="keyword">using</span> System.Text;    </div><div class="line"><span class="keyword">using</span> System.Collections;    </div><div class="line">  </div><div class="line">namespace HeapBlock    </div><div class="line">{    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> WoolWall    </div><div class="line">    {            </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n;    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> height;    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxState;    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[, ,] resultCache;   <span class="comment">//结果缓存数组    </span></div><div class="line">  </div><div class="line">        <span class="keyword">public</span> <span class="title">WoolWall</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> height)    </div><div class="line">        {    </div><div class="line">            <span class="keyword">this</span>.n = n;    </div><div class="line">            <span class="keyword">this</span>.height = height;    </div><div class="line">            maxState = (<span class="number">1</span> &lt;&lt; height) - <span class="number">1</span>;    </div><div class="line">            resultCache = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>, maxState + <span class="number">1</span>, maxState + <span class="number">1</span>];   <span class="comment">//构建缓存数组，每个值默认为0；    </span></div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 静态入口。计算堆放方案数。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="n"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="k"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span>    </span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Heap</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k)    </div><div class="line">        {    </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WoolWall(n, k).Heap();    </div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 计算堆放方案数。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span>    </span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Heap</span>()    </div><div class="line">        {    </div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Heap(n, <span class="number">0</span>, <span class="number">0</span>);    </div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> <span class="title">Heap</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> lState, <span class="keyword">int</span> rState)    </div><div class="line">        {    </div><div class="line">            <span class="comment">//如果缓存数组中的值不为0，则表示该结果已经存在缓存中。    </span></div><div class="line">            <span class="comment">//直接返回缓存结果。    </span></div><div class="line">            <span class="keyword">if</span> (resultCache[n, lState, rState] != <span class="number">0</span>)    </div><div class="line">            {    </div><div class="line">                <span class="keyword">return</span> resultCache[n, lState, rState];    </div><div class="line">            }    </div><div class="line">  </div><div class="line">            <span class="comment">//在只有一列的情况，无法再进行切分    </span></div><div class="line">            <span class="comment">//根据列状态计算一列的堆放方案    </span></div><div class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)    </div><div class="line">            {    </div><div class="line">                <span class="keyword">return</span> CalcOneColumnHeapCount(lState);    </div><div class="line">            }    </div><div class="line">  </div><div class="line">            <span class="keyword">long</span> result = <span class="number">0</span>;    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= maxState; state++)    </div><div class="line">            {    </div><div class="line">                <span class="keyword">if</span> (n == <span class="number">1</span>)    </div><div class="line">                {    </div><div class="line">                    <span class="comment">//在只有两列的情况，判断当前状态在切分之后是否有效    </span></div><div class="line">                    <span class="keyword">if</span> (!StateIsAvailable(n, lState, rState, state))    </div><div class="line">                    {    </div><div class="line">                        <span class="keyword">continue</span>;    </div><div class="line">                    }    </div><div class="line">                    result += Heap(n - <span class="number">1</span>, state | lState, state | lState)  <span class="comment">//合并状态。因为只有一列，所以lState和rState相同。    </span></div><div class="line">                        * Heap(n - <span class="number">1</span>, state | rState, state | rState);    </div><div class="line">                }    </div><div class="line">                <span class="keyword">else</span>    </div><div class="line">                {    </div><div class="line">                    result += Heap(n - <span class="number">1</span>, lState, state) * Heap(n - <span class="number">1</span>, state, rState);     </div><div class="line">                }    </div><div class="line">                result %= <span class="number">1000000007</span>;<span class="comment">//为了防止结果溢出，根据题目要求求模。    </span></div><div class="line">            }    </div><div class="line">  </div><div class="line">            resultCache[n, lState, rState] = (<span class="keyword">int</span>)result;   <span class="comment">//将结果写入缓存数组中    </span></div><div class="line">            resultCache[n, rState, lState] = (<span class="keyword">int</span>)result;   <span class="comment">//对称的墙结果相同，所以直接写入缓存。    </span></div><div class="line">            <span class="keyword">return</span> result;    </div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 根据一列的状态，计算列的堆放方案数。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="state"&gt;</span>状态<span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span>    </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CalcOneColumnHeapCount</span>(<span class="keyword">int</span> state)    </div><div class="line">        {    </div><div class="line">            <span class="keyword">int</span> sn = <span class="number">0</span>; <span class="comment">//连续计数    </span></div><div class="line">            <span class="keyword">int</span> result = <span class="number">1</span>;    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)    </div><div class="line">            {    </div><div class="line">                <span class="keyword">if</span> ((state & <span class="number">1</span>) == <span class="number">0</span>)    </div><div class="line">                {    </div><div class="line">                    sn++;    </div><div class="line">                }    </div><div class="line">                <span class="keyword">else</span>    </div><div class="line">                {    </div><div class="line">                    <span class="keyword">if</span> (sn &gt; <span class="number">0</span>)    </div><div class="line">                    {    </div><div class="line">                        result *= CalcAllState(sn);    </div><div class="line">                    }    </div><div class="line">                    sn = <span class="number">0</span>;    </div><div class="line">                }    </div><div class="line">                state &gt;&gt;= <span class="number">1</span>;    </div><div class="line">            }    </div><div class="line">            <span class="keyword">if</span> (sn &gt; <span class="number">0</span>)    </div><div class="line">            {    </div><div class="line">                result *= CalcAllState(sn);    </div><div class="line">            }    </div><div class="line">  </div><div class="line">            <span class="keyword">return</span> result;    </div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 类似于斐波那契序列。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> f(1)=1    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> f(2)=2    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> f(n) = f(n-1)*f(n-2);    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 只是初始值不同。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="k"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span>    </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CalcAllState</span>(<span class="keyword">int</span> k)    </div><div class="line">        {    </div><div class="line">            <span class="keyword">return</span> k &lt;= <span class="number">2</span> ? k : CalcAllState(k - <span class="number">1</span>) + CalcAllState(k - <span class="number">2</span>);    </div><div class="line">        }    </div><div class="line">  </div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 判断状态是否可用。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 当n=1时，分割之后，左墙和右边墙只有一列。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 所以state的状态码可能会覆盖原来的边缘状态。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 如果有覆盖，则该状态不可用；没有覆盖则可用。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> 当n&gt;1时，不存在这种情况，都返回状态可用。    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="n"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="lState"&gt;</span>左边界状态<span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="rState"&gt;</span>右边界状态<span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="state"&gt;</span>切开位置的当前状态<span class="xmlDocTag">&lt;/param&gt;</span>    </span></div><div class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>状态有效返回 true,状态不可用返回 false<span class="xmlDocTag">&lt;/returns&gt;</span>    </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">StateIsAvailable</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> lState, <span class="keyword">int</span> rState, <span class="keyword">int</span> state)    </div><div class="line">        {    </div><div class="line">            <span class="keyword">return</span> (n &gt; <span class="number">1</span>) || ((lState | state) == lState + state && (rState | state) == rState + state);    </div><div class="line">        }    </div><div class="line">    }    </div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述程序中，</p>
<ul>
<li><p>WoolWall.Heap(1024,4); //直接通过静态方法获得结果</p>
</li>
<li><p>new  WoolWall(n, k).Heap();//通过构造对象获得结果</p>
</li>
</ul>
<h5 id="2-3-1、核心算法讲解">2.3.1、核心算法讲解</h5>
<p>因为它最终都是分解成一列的情况进行处理，这就会导致很慢。为了提高速度，本文使用了缓存机制来提高性能。缓存原理就是，n,k,leftState,rightState相同的墙，返回的结果肯定相同。利用这个特性，每计算一种结果就放入到缓存中，如果下次计算直接从缓存取出。刚开始缓存用字典类实现，有网友给出了更好的缓存方法——数组。这样性能好了很多，也更加简单。程序结构如下图所示：</p>
<p><img src="../images/32~33/33.24.jpg" alt=""></p>
<p>上图反应了Heap调用的主要方法调用，在循环中，result 累加 lResult 和 rResult。</p>
<p>①在实际代码中，首先是从缓存中读取结果，如果没有从缓存中读取结果再进行计算。 </p>
<p>分解到一列时，不再分解，直接计算结果</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)  </div><div class="line">{  </div><div class="line">     <span class="keyword">return</span> CalcOneColumnHeap(lState);  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>②下面是整个程序的核心代码，通过for循环，求和state=0到state=2^k-1的两边木墙乘积：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= maxState; state++)  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span> (!StateIsAvailable(n, lState, rState, state))  </div><div class="line">        {  </div><div class="line">            <span class="keyword">continue</span>;  </div><div class="line">        }  </div><div class="line">        result += Heap(n - <span class="number">1</span>, state | lState, state | lState) *  </div><div class="line">            Heap(n - <span class="number">1</span>, state | rState, state | rState);  </div><div class="line">    }  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    {  </div><div class="line">        result += Heap(n - <span class="number">1</span>, lState, state)  </div><div class="line">            * Heap(n - <span class="number">1</span>, state, rState);  </div><div class="line">    }  </div><div class="line">    result %= <span class="number">1000000007</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>当n=1切分时，需要特殊考虑。如下图：</p>
<p><img src="../images/32~33/33.25.jpg" alt=""></p>
<p>图2-8</p>
<p>看上图中，因为左边墙中间被绿色方块占用，所以在（1,0）-（1,1）这个位置（位置的标记方法同解法一）不能再放绿色方块。所以一些状态需要排除，如state=2需要排除。同时在还需要合并状态，如state=1时，左边墙的状态=3。</p>
<p>特别说明下：依据我们上文2.2节中的公式，如果第i行有这种木块，state对应2^(i-1)，加上所有行的贡献就得到state（0就是没有这种横跨木块，2^k-1就是所有行都是横跨木块），然后遍历state，还记得上文中的图2-7么？</p>
<p><img src="../images/32~33/33.26.jpg" alt=""></p>
<p>当第i行被这样的木块<img src="../images/32~33/33.27.jpg" alt="">或这样的木块<img src="../images/32~33/33.28.jpg" alt="">占据时，其各自对应的state值分别为：</p>
<p>1.当第1行被占据，state=1；</p>
<p>2.当第2行被占据，state=2；</p>
<p>3.当第1和第2行都被占据，state=3；</p>
<p>4.当第3行被占据，state=4；</p>
<p>5.当第1和第3行被占据，state=5；</p>
<p>6.当第2和第3行被占据，state=6；</p>
<p>7.当第1、2、3行全部都被占据，state=7。</p>
<p>至于原因，即如2.1.3节节末所说：二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7。</p>
<p>具体来说，下面图中所有框出来的位置，不能有绿色的：</p>
<p><img src="../images/32~33/33.29.jpg" alt=""></p>
<p>③CalcOneColumnHeap(int state)函数用于计算一列时摆放方案数。</p>
<p>计算方法是， 求和被绿色木块分割开的每一段连续方格的摆放方案数。每一段连续的方格的摆放方案通过CalcAllState方法求得。经过分析，可以得知CalcAllState是类似斐波那契序列的函数。</p>
<p>举个例子如下（分步骤讲述）：</p>
<p>1.令state = 4546（state=2^k-1，k最大为4，故本题中state最大在15，而这里取state=4546只是为了演示如何计算），二进制是：1000111000010。位置上为1，表示被绿色木块占用，0表示空着，可以自由摆放。</p>
<p>2.1000111000010  被分割后 1  000  111  0000  1  0, 那么就有 000=3个连续位置， 0000=4个连续位置 ， 0=1个连续位置。</p>
<p>3.堆放结果=CalcAllState(3) + CalcAllState(4) + CalcAllState(1) = 3 + 5 + 1 = 9。</p>
<h4 id="2-4、再次优化">2.4、再次优化</h4>
<p>上面程序因为调用性能的树形结构，形成了大量的函数调用和缓存查找，所以其性能不是很高。 为了得到更高的性能，可以让所有的运算直接依赖于上一次运算的结果，以防止更多的调用。即如果每次运算都算出所有边界状态的结果，那么就能为下一次运算提供足够的信息。后续优化请<a href="http://blog.csdn.net/dw14132124/article/details/9038417#t2" target="_blank" rel="external">查阅此文第3节</a>。</p>
<h3 id="解法三、动态规划">解法三、动态规划</h3>
<p>相信读到上文，不少读者都已经意识到这个问题其实就是一个动态规划问题，接下来咱们换一个角度来分析此问题。</p>
<h4 id="3-1、暴力搜索不可行">3.1、暴力搜索不可行</h4>
<p>首先，因为木块的宽度都是1，我们可以想成2维的问题。也就是说三种木板的规格分别为1<em> 1, 1 </em> 2, 2 * 1。</p>
<p>通过上文的解法一，我们已经知道这个问题最直接的想法就是暴力搜索，即对每个空格尝试放置哪种木板。但是看看数据规模就知道，这种思路是不可行的。因为有一条边范围长度高达2^1024，普通的电脑，2^30左右就到极限了。于是我们得想想别的方法。</p>
<h4 id="3-2、另辟蹊径">3.2、另辟蹊径</h4>
<p>为了方便，我们把墙看做有2^n行，k列的矩形。这是因为虽然矩形木块不能翻转，但是我们同时拥有1<em>2和2</em>1的两种木块。</p>
<p>假设我们从上到下，从左到右考虑每个1*1的格子是如何被覆盖的。显然，我们每个格子都要被覆盖住。木块的特点决定了我们覆盖一个格子最多只会影响到下一行的格子。这就可以让我们暂时只考虑两行。</p>
<p>假设现我们已经完全覆盖了前(i–1)行。那么由于覆盖前(i-1)行导致第i行也不“完整”了。如下图：</p>
<p>xxxxxxxxx</p>
<p>ooxooxoxo</p>
<p>我们用x表示已经覆盖的格子，o表示没覆盖的格子。为了方便，我们使用9列。</p>
<p>我们考虑第i行的状态，上图中，第1列我们可以用1<em>1的覆盖掉，也可以用1</em>2的覆盖前两列。第4、5列的覆盖方式和第1、2列是同样的情况。第7列需要覆盖也有两种方式，即用1<em>1的覆盖或者用2</em>1的覆盖，但是这样会导致第（i+1)行第7列也被覆盖。第9列和第7列的情况是一样的。这样把第i行覆盖满了之后，我们再根据第(i+1)行被影响的状态对下一行进行覆盖。</p>
<p>那么每行有多少种状态呢？显然有2^k，由于k很小，我们只有大约16种状态。如果我们对于这些状态之间的转换制作一个矩阵，矩阵的第i行第j列的数表示的是我们第m行是状态i，我们把它完整覆盖掉，并且使得第(m + 1)行变成状态j的可能的方法数，这个矩阵我们可以暴力搜索出来，搜索的方式就是枚举第m行的状态，然后尝试放木板，用所有的方法把第m行覆盖掉之后，下一行的状态。当然，我们也可以认为只有两行，并且第一行是2k种状态的一种，第二行起初是空白的，求使得第一行完全覆盖掉，第二行的状态有多少种类型以及每种出现多少次。</p>
<h4 id="3-3、动态规划">3.3、动态规划</h4>
<p>这个矩阵作用很大，其实我们覆盖的过程可以认为是这样：第一行是空的，我们看看把它覆盖了，第2行是什么样子的。根据第二行的状态，我们把它覆盖掉，看看第3行是什么样子的。</p>
<p>如果我们知道第i行的状态为s,怎么考虑第i行完全覆盖后，第(i+1)行的状态？那只要看那个矩阵的状态s对应的行就可以了。我们可以考虑一下，把两个这样的方阵相乘得到得结果是什么。这个方阵的第i行第j个元素是这样得到的，是第i行第k个元素与第k行第j个元素的对k的叠加。它的意义是上一行是第m行是状态i，把第m行和第(m+1)行同时覆盖住，第(m+2)行的状态是j的方法数。这是因为中间第(m+1)行的所有状态k，我们已经完全遍历了。</p>
<p>于是我们发现，每做一次方阵的乘法，我们相当于把状态推动了一行。那么我们要坐多少次方阵乘法呢？就是题目中墙的长度2<sup>n</sup>,这个数太大了。但是事实上，我们可以不断地平方n次。也就是说我们可以算出A<sup>2</sup>,A<sup>4</sup>, A<sup>8</sup>, A<sup>16</sup>……方法就是不断用结果和自己相乘，这样乘n次就可以了。</p>
<p>因此，我们最关键的问题就是建立矩阵A。我们可以这样表示一行的状态，从左到右分别叫做第0列，第1列……覆盖了我们认为是1，没覆盖我们认为是0，这样一行的状态可以表示为一个整数。某一列的状态我们可以用位运算来表示。例如，状态x第i列是否被覆盖，我们只需要判断x &amp; (1 &lt;&lt; i) 是否非0即可，或者判断(x &gt;&gt; i) &amp; 1， 用右移位的目的是防止溢出，但是本题不需要考虑溢出，因为k很小。 接下来的任务就是递归尝试放置方案了</p>
<h4 id="3-4、参考代码">3.4、参考代码</h4>
<p>最终结果，我们最初的行是空得，要求最后一行之后也不能被覆盖，所以最终结果是矩阵的第[0][0]位置的元素。另外，本题在乘法过程中会超出32位int的表示范围，需要临时用C/C++的long long，或者java的long。</p>
<p>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//copyright@caopengcs 12/08/2013  </span></div><div class="line"><span class="preprocessor">#ifdef WIN32  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ll __int64   </span></div><div class="line"><span class="preprocessor">#<span class="keyword">else</span>  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> ll long long  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span>  </span></div><div class="line">  </div><div class="line"><span class="comment">// 1 covered 0 uncovered  </span></div><div class="line">  </div><div class="line"><span class="keyword">void</span> cal(<span class="keyword">int</span> a[<span class="number">6</span>][<span class="number">32</span>][<span class="number">32</span>],<span class="keyword">int</span> n,<span class="keyword">int</span> col,<span class="keyword">int</span> laststate,<span class="keyword">int</span> nowstate)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (col &gt;= n)</div><div class="line">    {</div><div class="line">        ++a[n][laststate][nowstate];  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    }  </div><div class="line">    <span class="comment">//不填 或者用1*1的填  </span></div><div class="line">    cal(a,n, col + <span class="number">1</span>, laststate, nowstate);  </div><div class="line">    <span class="keyword">if</span> (((laststate &gt;&gt; col) & <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">    {</div><div class="line">        cal(a,n, col + <span class="number">1</span>, laststate, nowstate | (<span class="number">1</span> &lt;&lt; col));  </div><div class="line">        <span class="keyword">if</span> ((col + <span class="number">1</span> &lt; n) && (((laststate &gt;&gt; (col + <span class="number">1</span>)) & <span class="number">1</span>) == <span class="number">0</span>))</div><div class="line">        {</div><div class="line">            cal(a,n, col + <span class="number">2</span>, laststate, nowstate);  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">inline</span> <span class="keyword">int</span> mul(ll x, ll y)</div><div class="line">{</div><div class="line">    <span class="keyword">return</span> x * y % <span class="number">1000000007</span>;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> multiply(<span class="keyword">int</span> n,<span class="keyword">int</span> a[][<span class="number">32</span>],<span class="keyword">int</span> b[][<span class="number">32</span>])</div><div class="line">{ <span class="comment">// b = a * a</span></div><div class="line">    <span class="keyword">int</span> i,j, k;  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</div><div class="line">        {</div><div class="line">            <span class="keyword">for</span> (k = b[i][j] = <span class="number">0</span>; k &lt; n; ++k)</div><div class="line">            {</div><div class="line">                <span class="keyword">if</span> ((b[i][j] += mul(a[i][k],a[k][j])) &gt;= <span class="number">1000000007</span>)</div><div class="line">                {</div><div class="line">                    b[i][j] -= <span class="number">1000000007</span>;</div><div class="line">                }  </div><div class="line">            }  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> calculate(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> i, j;  </div><div class="line">    <span class="keyword">int</span> a[<span class="number">6</span>][<span class="number">32</span>][<span class="number">32</span>],mat[<span class="number">2</span>][<span class="number">32</span>][<span class="number">32</span>];  </div><div class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</div><div class="line">    {</div><div class="line">        <span class="keyword">for</span> (j = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</div><div class="line">        {</div><div class="line">            cal(a,i, <span class="number">0</span>, j, <span class="number">0</span>);  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">    <span class="built_in">memcpy</span>(mat[<span class="number">0</span>], a[k],<span class="keyword">sizeof</span>(mat[<span class="number">0</span>]));  </div><div class="line">    k = (<span class="number">1</span> &lt;&lt; k);  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; n; --n)</div><div class="line">    {</div><div class="line">        multiply(k, mat[i], mat[i ^ <span class="number">1</span>]);  </div><div class="line">        i ^= <span class="number">1</span>;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> mat[i][<span class="number">0</span>][<span class="number">0</span>];  </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考链接及推荐阅读">参考链接及推荐阅读</h2>
<ol>
<li>caopengcs，<a href="http://blog.csdn.net/caopengcs/article/details/9928061" target="_blank" rel="external">木块砌墙</a></li>
<li>红色标记，<a href="http://blog.csdn.net/dw14132124/article/details/9038417" target="_blank" rel="external">木块砌墙</a></li>
<li>LoveHarvy，<a href="http://blog.csdn.net/wangyan_boy/article/details/9131501" target="_blank" rel="external">木块砌墙</a></li>
<li><a href="http://hero.pongo.cn/Question/Details?ID=36&amp;ExamID=36" target="_blank" rel="external">在线编译测试木块砌墙问题</a></li>
<li>hero上<a href="http://hero.pongo.cn/Question/Details?ExamID=36&amp;ID=36&amp;bsh_bid=273040296" target="_blank" rel="external">木块砌墙一题</a></li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>


<div class="article-share" id="share">

  <div data-url="http://qiaoidea.github.io/programing_art/ebook/zh/木块砌墙原稿.html" data-title="Qiaoidea&#39;s Blog" data-tsina="5288126184" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
	
<section id="comments" class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
        </div>
        <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 一时不学，差之毫厘； <br/>
			终日不学，失之千里。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5288126184" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2015 
		
		<a href="http://qiaoidea.github.io/about" target="_blank" title="Qiaoidea">Qiaoidea</a>
		
		</p>
</div>
</footer>
        <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"qiaoidea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

      </body>
     </html>
     
